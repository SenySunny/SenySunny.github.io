<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ESP32学习笔记（一）：ESP-IDF配合VSCode的一些方法和技巧</title>
    <url>/articles/esp32_0001.html</url>
    <content><![CDATA[<h3 id="1、idf的常用基本命令"><a href="#1、idf的常用基本命令" class="headerlink" title="1、idf的常用基本命令"></a>1、idf的常用基本命令</h3><h4 id="1-查看芯片信息：esptool-py-p-COM4-flash-id"><a href="#1-查看芯片信息：esptool-py-p-COM4-flash-id" class="headerlink" title="(1). 查看芯片信息：esptool.py -p COM4 flash_id"></a>(1). 查看芯片信息：<code>esptool.py -p COM4 flash_id</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esptool.py -p COM4 flash_id</span><br></pre></td></tr></table></figure>

<h4 id="2-选择芯片命令：idf-py-set-target-esp32"><a href="#2-选择芯片命令：idf-py-set-target-esp32" class="headerlink" title="(2). 选择芯片命令：idf.py set-target esp32"></a>(2). 选择芯片命令：<code>idf.py set-target esp32</code></h4><p>​		详细的命令格式为：<code>idf.py set-target [OPTIONS] &#123;esp32|esp32s2|esp32c3|esp32s3|esp32c2|esp32c6|esp32h2|linux&#125;</code></p>
<p>​    	所以我们如果选择ESP32S3，则可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf.py set-target esp32s3</span><br></pre></td></tr></table></figure>

<h4 id="3-编译命令：idf-py-build"><a href="#3-编译命令：idf-py-build" class="headerlink" title="(3). 编译命令：idf.py build"></a>(3). 编译命令：<code>idf.py build</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf.py build</span><br></pre></td></tr></table></figure>

<h4 id="4-配置命令：-idf-py-menuconfig"><a href="#4-配置命令：-idf-py-menuconfig" class="headerlink" title="(4). 配置命令： idf.py menuconfig"></a>(4). 配置命令： <code>idf.py menuconfig</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf.py menuconfig</span><br></pre></td></tr></table></figure>

<h4 id="6-下载命令：-idf-py-p-COM3-flash"><a href="#6-下载命令：-idf-py-p-COM3-flash" class="headerlink" title="(6). 下载命令： idf.py -p COM3 flash"></a>(6). 下载命令： <code>idf.py -p COM3 flash</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf.py -p COM3 flash</span><br></pre></td></tr></table></figure>

<h4 id="7-console调试命令：-idf-py-p-COM3-monitor"><a href="#7-console调试命令：-idf-py-p-COM3-monitor" class="headerlink" title="(7). console调试命令： idf.py -p COM3 monitor"></a>(7). console调试命令： <code>idf.py -p COM3 monitor</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">idf.py -p COM3 monitor</span><br></pre></td></tr></table></figure>

<h4 id="8-退出调试模式：-ctrl"><a href="#8-退出调试模式：-ctrl" class="headerlink" title="(8). 退出调试模式： ctrl + ]"></a>(8). 退出调试模式： <code>ctrl + ]</code></h4><h4 id="9-更新esptool：-pip-install-upgrade-esptool"><a href="#9-更新esptool：-pip-install-upgrade-esptool" class="headerlink" title="(9).更新esptool： pip install --upgrade esptool"></a>(9).更新esptool： <code>pip install --upgrade esptool</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --upgrade esptool</span><br></pre></td></tr></table></figure>



<h4 id="10-关于idf版本相关内容"><a href="#10-关于idf版本相关内容" class="headerlink" title="(10). 关于idf版本相关内容"></a>(10). 关于idf版本相关内容</h4><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.1.3/esp32s3/versions.html">https://docs.espressif.com/projects/esp-idf/zh_CN/v5.1.3/esp32s3/versions.html</a></p>
<p>可以通过如下代码来下载idf的源码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $IDF_PATH</span><br><span class="line">git fetch</span><br><span class="line">git checkout vX.Y.Z</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>


<h3 id="2、idf和-vscode的一些说明和细节"><a href="#2、idf和-vscode的一些说明和细节" class="headerlink" title="2、idf和 vscode的一些说明和细节"></a>2、idf和 vscode的一些说明和细节</h3><h4 id="1-ESP-IDF-CMD和-ESP-IDF-PowerShell终端快捷方式"><a href="#1-ESP-IDF-CMD和-ESP-IDF-PowerShell终端快捷方式" class="headerlink" title="(1).  ESP-IDF CMD和 ESP-IDF PowerShell终端快捷方式"></a>(1).  ESP-IDF CMD和 ESP-IDF PowerShell终端快捷方式</h4><h5 id="1-终端快捷方式的解释"><a href="#1-终端快捷方式的解释" class="headerlink" title="1.  终端快捷方式的解释"></a>1.  终端快捷方式的解释</h5><ol>
<li><p>cmd的目标内容：<code>C:\WINDOWS\system32\cmd.exe /k &quot;&quot;D:\Espressif\idf_cmd_init.bat&quot; esp-idf-cc72132cd64ef413a5557253e3adc170&quot;</code></p>
</li>
<li><p>PowerShell的目标内容： <code>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -NoExit -File &quot;D:\Espressif/Initialize-Idf.ps1&quot; -IdfId esp-idf-cc72132cd64ef413a5557253e3adc170</code></p>
</li>
<li><p>它们的起始位置：<code>D:\Espressif\frameworks\esp-idf-v5.1\</code></p>
<p>   本质上idf就是创建了一个Python的虚拟环境，并针对该环境配置了环境变量，配置环境变量的内容可以详解idf安装目录下的<code>idf_cmd_init.bat</code>(针对cmd)和<code>Initialize-Idf.ps1</code>(针对powershell)。</p>
<p> 而&#x2F;k是cmd的参数，表示”保持命令行窗口打开”,表示在执行完idf_cmd_init.bat保持终端窗口打开，这样可以确保创建的虚拟环境在在终端中有效，也就是关闭了终端，虚拟环境就关闭了，环境变量也随之无效。</p>
<p> <code>esp-idf-cc72132cd64ef413a5557253e3adc170</code>是idf软件的id，用来表示该idf软件，其在软件安装目录下的<code>esp_idf.json</code>中定义，为<code>idfSelectedId</code>的值。<code>esp_idf.json</code>文件内容如下：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://json-schema.org/schema#&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://dl.espressif.com/dl/schemas/esp_idf&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Configuration file for ESP-IDF Eclipse plugin.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_warning&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Use / or \\ when specifying path. Single backslash is not allowed by JSON format.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gitPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Espressif/tools/idf-git/2.39.2/cmd/git.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idfToolsPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idfSelectedId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esp-idf-cc72132cd64ef413a5557253e3adc170&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idfInstalled&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;esp-idf-cc72132cd64ef413a5557253e3adc170&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;python&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Espressif/python_env/idf5.1_py3.11_env/Scripts/python.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Espressif/frameworks/esp-idf-v5.1/&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    <code>-ExecutionPolicy Bypass</code>目的是关闭powershell的安全策略，这是由于PowerShell有一个安全特性，可以限制未经签名的脚本的执行，所以需要配置Bypass选项，用来允许执行任何脚本，无视这些安全限制，以确保可以运行Initialize-Idf.ps1脚本。</p>
<p>​    <code>-NoExit</code>与cmd终端中的<code>/k</code>作用一样，指示PowerShell在脚本执行完毕后不要关闭窗口，允许用户在同一窗口继续执行更多命令。</p>
<p>​    <code>-File &quot;D:\Espressif/Initialize-Idf.ps1&quot; </code>表示运行该脚本，用于设置ESP-IDF开发环境，与cmd终端的<code>idf_cmd_init.bat</code>作用相同，详细可以看批处理和脚本的内容<br>​    <code>-IdfId esp-idf-cc72132cd64ef413a5557253e3adc170</code>则表示在执行<code>Initialize-Idf.ps1</code>脚本时，给脚本中的IdfId变量复制为<code>esp-idf-cc72132cd64ef413a5557253e3adc170</code>这个值。<br>​    通过以上解释，我们大致理解了idf-env工具的作用了。这意味着，实际上，我们可以在任何终端窗口，输入如下内容就可以进行idf的使用：</p>
<h5 id="2-一种多版本安装方法："><a href="#2-一种多版本安装方法：" class="headerlink" title="2. 一种多版本安装方法："></a>2. 一种多版本安装方法：</h5><p>   根据前面的终端的解释，所以我这边进行一种多版本idf的安装方法，我首先给电脑安装一个默认版本的idf，这里选择了idf v5.1版本（至于原因，后面有讲），我是安装在<code>D:\Espressif</code>目录下，然后再<code>Espressif</code>目录下又创建了几个其他版本的idf，直接取名版本号如下图：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111823712.png" alt="idf安装"></p>
<p>   这个时候每安装完成一个版本，可以把该版本的终端快捷方式复制出来，放在桌面的一个文件夹内，这里我取名idf,就可以实现多有版本的终端编译功能。最后所有版本的快捷方式如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111823623.png" alt="idf快捷方式"></p>
<blockquote>
<p>   这里需要注意两点：</p>
<ol>
<li><p>安装其他版本的时候，有可能导致，目录下<code>esp_idf.json</code>文件对应的目录内容改变，我记得好像是<code>&quot;gitPath&quot;</code>变量的值会修改，可以修改为对应版本的idf的目录，详细json的值可以参考第一节对快捷方式的解释内容。</p>
</li>
<li><p>安装可能会再用户环境变量中添加名称为<code>IDF_TOOLS_PATH</code>的环境变量，默认是安装最后一个版本的idf的目录，比如<code>D:\Espressif\v5_1_3</code>,这里可以直接把该环境变量删除掉。否则可能会导致终端快捷方式运行出错（快捷方式运行的时候会首先读取<code>IDF_TOOLS_PATH</code>的值，如果有，则默认定义该值为软件目录，没有则会自动创建批处理文件的目录为<code>IDF_TOOLS_PATH</code>）这里给出<code>idf_cmd_init.bat</code>这部分的定义如下：</p>
</li>
</ol>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;%IDF_TOOLS_PATH%&quot;</span> == <span class="string">&quot;&quot;</span> (</span><br><span class="line"> <span class="built_in">set</span> IDF_TOOLS_PATH=%~dp0</span><br><span class="line"> <span class="built_in">echo</span> IDF_TOOLS_PATH not <span class="built_in">set</span>. Setting to %~dp0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>   此时VScode中默认绑定默认版本的idf。其他版本的编译有两种思路：</p>
<p>   一种是直接再vscode中打开终端，然后输入语句来设置对应版本的idf的环境变量和配置，然后用idf的指令进行编译下载和调试；</p>
<p>   另外一种方式是，针对每种版本的idf创建一个vscode工作区参数设置文件，直接把该文件复制到需要运行的idf工程中，此时，vscode会自动设置idf的工作区目录，并使用特定版本的idf来编译和下载程序。这个方法参考了B站UP主“<a href="https://space.bilibili.com/34165842">第九个下弦月</a>”的一个视频内容提供的 vscode 工作区的概念，详细视频地址为：<a href="https://www.bilibili.com/video/BV1bj421Z7z4/?spm_id_from=333.337.search-card.all.click&vd_source=50e88259c3b06cefc86b0480e57ce888">https://www.bilibili.com/video/BV1bj421Z7z4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=50e88259c3b06cefc86b0480e57ce888</a></p>
<h5 id="3-终端环境变量配置语句："><a href="#3-终端环境变量配置语句：" class="headerlink" title="3. 终端环境变量配置语句："></a>3. 终端环境变量配置语句：</h5><p>   首先是默认版本，我的是v5.1，直接再vscode终端中输入如下语句（一个采用cmd，一个采用powershell），既可再改终端之后，使用针对该版本的idf命令，实现编译和下载等功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd /k &quot;&quot;D:\Espressif\idf_cmd_init.bat&quot; esp-idf-cc72132cd64ef413a5557253e3adc170&quot;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-ExecutionPolicy</span> Bypass <span class="literal">-NoExit</span> <span class="operator">-File</span> <span class="string">&quot;D:\Espressif/Initialize-Idf.ps1&quot;</span> <span class="literal">-IdfId</span> esp<span class="literal">-idf-cc72132cd64ef413a5557253e3adc170</span></span><br></pre></td></tr></table></figure>

<p>   如果是V5.1.3版本，id号不一样，用改语句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd /k &quot;&quot;D:\Espressif\v5_1_3\idf_cmd_init.bat&quot; esp-idf-2f332dae01e5300d41bb5887948c6ac3&quot;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-ExecutionPolicy</span> Bypass <span class="literal">-NoExit</span> <span class="operator">-File</span> <span class="string">&quot;D:\Espressif\v5_1_3/Initialize-Idf.ps1&quot;</span> <span class="literal">-IdfId</span> esp<span class="literal">-idf-2f332dae01e5300d41bb5887948c6ac3</span></span><br></pre></td></tr></table></figure>
<p>   如果是V5.2.1版本，id号不一样，用改语句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd /k &quot;&quot;D:\Espressif\v5_2_1\idf_cmd_init.bat&quot; esp-idf-f2854e5176bb04b11fdfe329dc6d2d14&quot;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-ExecutionPolicy</span> Bypass <span class="literal">-NoExit</span> <span class="operator">-File</span> <span class="string">&quot;D:\Espressif\v5_2_1/Initialize-Idf.ps1&quot;</span> <span class="literal">-IdfId</span> esp<span class="literal">-idf-f2854e5176bb04b11fdfe329dc6d2d14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>   注意：安装位置不同，这个生成的码也不同，应该是根据版本号，安装位置等信息生成的唯一识别码。</p>
</blockquote>
<h5 id="4-vscode-工作区配置文件"><a href="#4-vscode-工作区配置文件" class="headerlink" title="4. vscode 工作区配置文件"></a>4. vscode 工作区配置文件</h5><p>   如果不希望再vscode中用终端来编译和下载文件，而是希望直接用vscode下方的快捷键来操作，而且可以实现在一台电脑上随时切换不同版本的idf工程，可以针对每个版本创建一个 vscode 工作区配置文件，把该文件复制到工程目录下，文件后缀需要为：<code>xxx.code-workspace</code>,比如，下面是我针对v5.2.1版本创建的文件，取名为<code>idf_5.2.1.code-workspace</code>内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;folders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;idf.espIdfPathWin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\frameworks\\esp-idf-v5.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idf.pythonBinPathWin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\python_env\\idf5.2_py3.11_env\\Scripts\\python.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idf.toolsPathWin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idf.customExtraPaths&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\tools\\xtensa-esp-elf-gdb\\12.1_20231023\\xtensa-esp-elf-gdb\\bin;D:\\Espressif\\v5_2_1\\tools\\riscv32-esp-elf-gdb\\12.1_20231023\\riscv32-esp-elf-gdb\\bin;D:\\Espressif\\v5_2_1\\tools\\xtensa-esp-elf\\esp-13.2.0_20230928\\xtensa-esp-elf\\bin;D:\\Espressif\\v5_2_1\\tools\\riscv32-esp-elf\\esp-13.2.0_20230928\\riscv32-esp-elf\\bin;D:\\Espressif\\v5_2_1\\tools\\esp32ulp-elf\\2.35_20220830\\esp32ulp-elf\\bin;D:\\Espressif\\v5_2_1\\tools\\cmake\\3.24.0\\bin;D:\\Espressif\\v5_2_1\\tools\\openocd-esp32\\v0.12.0-esp32-20230921\\openocd-esp32\\bin;D:\\Espressif\\v5_2_1\\tools\\ninja\\1.11.1;D:\\Espressif\\v5_2_1\\tools\\idf-exe\\1.0.3;D:\\Espressif\\v5_2_1\\tools\\ccache\\4.8\\ccache-4.8-windows-x86_64;D:\\Espressif\\v5_2_1\\tools\\dfu-util\\0.11\\dfu-util-0.11-win64;D:\\Espressif\\v5_2_1\\tools\\esp-rom-elfs\\20230320&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idf.customExtraVars&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;OPENOCD_SCRIPTS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\tools\\openocd-esp32\\v0.12.0-esp32-20230921/openocd-esp32/share/openocd/scripts&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;IDF_CCACHE_ENABLE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ESP_ROM_ELF_DIR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\tools\\esp-rom-elfs\\20230320/&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idf.gitPathWin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Espressif\\v5_2_1\\tools\\idf-git\\2.43.0\\cmd\\git.exe&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>   可以看到，其实它操作和终端配置环境变量差不多，就是设置idf工具的目录地址而已。其他版本可以参考这个来设置，这里不多赘述。需要做好的配置文件，可以直接到如下地址下载：<a href="https://gitee.com/SenySunny/picture/tree/master/idf_code-workspace">https://gitee.com/SenySunny/picture/tree/master/idf_code-workspace</a> </p>
<p>   另外，经部分电脑<code>xxx.code-workspace</code>文件并不会生效，针对这种情况，请直接把<code>&quot;settings&quot;</code>的内容（即所有的<code>idf.xxx</code>相关的软件目录选项）复制到<code>.vscode</code>目录下的<code>settings.json</code>文件中，然后重新打开工程目录。</p>
</blockquote>
<h4 id="2-vscode中的idf工程代码跳转问题"><a href="#2-vscode中的idf工程代码跳转问题" class="headerlink" title="(2).  vscode中的idf工程代码跳转问题"></a>(2).  vscode中的idf工程代码跳转问题</h4><p>   在vscode中建立idf工程，或者直接从idf中复制<code>example</code>例程创建工程修改时，默认情况下我们点击使用的idf中的api函数是无法跳转到idf目录下，可以通过如下手段，实现代码的跳转（默认是按下<code>Ctrl</code>+鼠标左击实现跳转）——注意需要vscode已经安装idf插件和<code>C/C++</code>插件。</p>
<p>   默认打开一个工程内的C文件，会在vscode的右下方出现win32的按钮图标（注意如下没有出现，可以尝试最大化vscode窗口），点击按钮，在弹出的选项栏中选择”编辑配置(JSON)”(也可以直接按住<code>Ctrl+P</code>按钮，在弹出的输入框输入<code>&gt; 编辑配置(JSON)</code>，效果一样)，此时，会自动为工程添加c_cpp_properties.json文件（在<code>.vscode</code>目录下）。</p>
<p>   在c_cpp_properties.json文件文件中的”configurations”属性添加一行代：<code>码&quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</code>， 注意json格式，需要在前面一行添加逗号，在正常添加之后的c_cpp_properties.json文件内容如下(不同环境下可能有所不同，只需要注意添加compileCommands属性即可)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.22621.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cl.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-msvc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>   此时在进行编译之后，会在build目录下产生一个compile_commands.json文件，此时，便可以按住ctrl键，鼠标点击特定函数，即使函数是在idf的内部，也可以实现跳转。</p>
<h4 id="3-在下载或者其他使用串口的时候，出现无法打开串口的情况解决办法（被占用）"><a href="#3-在下载或者其他使用串口的时候，出现无法打开串口的情况解决办法（被占用）" class="headerlink" title="(3). 在下载或者其他使用串口的时候，出现无法打开串口的情况解决办法（被占用）"></a>(3). 在下载或者其他使用串口的时候，出现无法打开串口的情况解决办法（被占用）</h4><p>  由于idf的操作都是在终端中进行的操作，如果它把串口占用了，可能会导致再次使用串口，出现无法打开串口的情况，此时可能会不清楚是哪个进程占用了串口的情况，导致无法使用串口（很多时候，即使把掉USB线，再插入也没有用，因为线程本身支持断线再插入的时候自动重新打开），可以通过如下方法来解除串口的占用。</p>
<ol>
<li><p>打开注册表，在系统的左下角软件搜索栏输入“regedit”，或者右击右下角windows图标选择“运行”， 输入regedit，都可以打开注册表</p>
</li>
<li><p>打开如下注册表选项<code>“计算机\HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM”</code>,在里面找到无法打开的注册表，如下图，我电脑是COM4</p>
</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111754694.png" alt="regedit_COMM"></p>
<ol start="3">
<li>复制它的名称，我的电脑为<code>\Device\USBSER000</code>.打开电脑资源管理器，选择“性能”选项卡， 点击下方的“打开资源监视器”，选择“CPU”，在关联的句柄中输入串口设备的名称，点击刷新，就可以看到占用串口的应用程序，选中右击，选择“结束进程”即可，此时，串口就又可以使用了,按照下图顺序操作即可。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111755363.png" alt="regedit_COMM2"></p>
<h4 id="4-关于USB-Serial-JTAG的一些问题（目前发现在v5-1中可以正常打印，其他版本可以用于log打印，但是直接用于stdin和stdout貌似有bug）"><a href="#4-关于USB-Serial-JTAG的一些问题（目前发现在v5-1中可以正常打印，其他版本可以用于log打印，但是直接用于stdin和stdout貌似有bug）" class="headerlink" title="(4). 关于USB-Serial-JTAG的一些问题（目前发现在v5.1中可以正常打印，其他版本可以用于log打印，但是直接用于stdin和stdout貌似有bug）"></a>(4). 关于USB-Serial-JTAG的一些问题（目前发现在v5.1中可以正常打印，其他版本可以用于log打印，但是直接用于stdin和stdout貌似有bug）</h4><p>​		目前发现USB-Serial-JTAG，在打印的时候，会有缓冲机制，也就是只有当收到\n字符（或者超时相关）的时候才会进行打印和输入，而且不管是绑定esp_vfs虚拟文件系统还是通过<code>fflush(stdout);</code>强制刷新输出缓冲流都没有用，这部分的内容可以参考： <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.2.1/esp32s3/api-guides/usb-serial-jtag-console.html">https://docs.espressif.com/projects/esp-idf/zh_CN/v5.2.1/esp32s3/api-guides/usb-serial-jtag-console.html</a> （无关版本问题，在5.1版本也一样）和 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32s3/api-guides/usb-serial-jtag-console.html">https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32s3/api-guides/usb-serial-jtag-console.html</a> ，在文章中是这样说明的：</p>
<p>​		对于从 ESP32-S3 发送到 PC 终端的数据（例如 stdout、日志），ESP32-S3 会先写入一个小型内部缓冲区。如果该缓冲区达到最大容量（例如没有连接 PC 终端），ESP32-S3 会进行一次等待，时长约 50 ms。在此期间，PC 终端可以请求数据，但可能会导致应用程序出现非常短暂的暂停。</p>
<p>​		对于从 PC 终端发送到 ESP32-S3 的数据（如控制台命令），许多 PC 终端会等待 ESP32-S3 接收字节后，再允许发送更多数据。这与使用 USB 转串口 (URAT) 桥接芯片不同，URAT 桥接芯片始终接收字节，并将其发送到（可能未在监听）的 ESP32-S3。</p>
<p>​		在极少数情况下，从 ESP32-S3 发送到主机的数据可能会“阻塞”在主机内存中。继续发送数据即可“取消阻塞”，但如果应用程序未继续发送数据，则需要手动将这些数据刷新到主机。能否继续发送数据取决于驱动程序，默认配置的非阻塞驱动程序和 VFS 实现会在换行后自动刷新，而基于中断的阻塞驱动程序会在发送缓冲区变空时自动刷新。</p>
<p>​		目前发现在5.1版本中通过设置usb_serial_jtag缓冲区，然后绑定esp_vfs。然后用<code>usb_serial_jtag_read_bytes</code>和<code>usb_serial_jtag_write_bytes</code>来替代<code>getchar</code>和<code>putchar</code>貌似在部分环境下有效（也可以使用putchar+fflush(stdout)），但是我测试在5.1.3版本中无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化usb_serial_jtag缓冲区，并绑定esp_vfs</span></span><br><span class="line"><span class="type">usb_serial_jtag_driver_config_t</span> usb_serial_jtag_config = &#123;</span><br><span class="line">      .rx_buffer_size = <span class="number">1024</span> * <span class="number">8</span>, .tx_buffer_size = <span class="number">1024</span> * <span class="number">2</span>&#125;;</span><br><span class="line">usb_serial_jtag_driver_install(&amp;usb_serial_jtag_config);</span><br><span class="line">esp_vfs_usb_serial_jtag_use_driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入采用如下形式</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">platform_getchar</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (usb_serial_jtag_read_bytes(buff, <span class="number">1</span>, <span class="number">100</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> buff[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出采用如下形式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">platform_putchar</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">  usb_serial_jtag_write_bytes(&amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//也可以使用如下两条语句替代代码</span></span><br><span class="line">  <span class="comment">//putchar(ch);</span></span><br><span class="line">  <span class="comment">//fflush(stdout);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		如果直接绑定console做标准输入输出，<code>printf</code>或者<code>putchar</code>都会直接进行usb的缓冲区，直到接收到<code>\n</code>字符（部分版本超时之后也会）之后才会一并通过usb_serial_jtag输出。</p>
<blockquote>
<p>​		所以目前发现如果希望使用USB-Serial-JTAG即作为下载程序，又充当一个标准串口来使用，目前最好用v5.1版本，如果不是充当标准串口，而支持用作log打印或者不介意数据缓冲问题的情况下，可以采用任意版本的idf。</p>
</blockquote>
<h3 id="3、idf的工程和工具补充"><a href="#3、idf的工程和工具补充" class="headerlink" title="3、idf的工程和工具补充"></a>3、idf的工程和工具补充</h3><h4 id="1-一些常见的menuconfig配置问题"><a href="#1-一些常见的menuconfig配置问题" class="headerlink" title="(1). 一些常见的menuconfig配置问题"></a>(1). 一些常见的menuconfig配置问题</h4><p>​		idf的工程 配置是通过menuconfig来实现的，menuconfig是一种工程代码管理工具，可以通过图形化配置界面，对工程的信息进行配置，这里对一些经常使用的menuconfig配置做一个说明</p>
<h5 id="1-Flash大小和CPU频率"><a href="#1-Flash大小和CPU频率" class="headerlink" title="1. Flash大小和CPU频率"></a>1. Flash大小和CPU频率</h5><p>​		比如ESP32-S3默认的flash大小是2M，CPU工作频率为160MHz这个可以修改成你的flash大小和频率如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111800041.png" alt="menuconfig_flash"></p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111800676.png" alt="menuconfig_cpu"></p>
<h5 id="2-修改主线程app-main的栈大小"><a href="#2-修改主线程app-main的栈大小" class="headerlink" title="2. 修改主线程app_main的栈大小"></a>2. 修改主线程app_main的栈大小</h5><p>​		当程序比较大时，可能会导致主线程堆栈太小，可以设置高一些。否则可能会给出<code>***ERROR*** A stack overflow in task main has been detected.</code>的报错信息。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111800096.png" alt="menuconfig_main_stack"></p>
<h5 id="3-flash分区表"><a href="#3-flash分区表" class="headerlink" title="3. flash分区表"></a>3. flash分区表</h5><p>​		esp-idf默认分区表如下，只占用了系统1M+64K的空间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name,   Type, SubType, Offset,  Size, Flags</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note: <span class="keyword">if</span> you have increased the bootloader size, make sure to update the offsets to avoid overlap</span></span><br><span class="line">nvs,      data, nvs,     0x9000,        0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,        0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000,		1M,</span><br></pre></td></tr></table></figure>

<p>​		而程序稍微大一些，空间就可能不够，所以一般项目大一些情况，我们会自定义分区表，可以直接在工程下创建<code>partitions.csv</code>文件，然后再menuconfig中选择自己创建的分区表信息，如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111800774.png" alt="menuconfig_partition"></p>
<p>​		具体分区表<code>partitions.csv</code>的内容可以参考		</p>
<h5 id="4-PSRAM的开启和使用"><a href="#4-PSRAM的开启和使用" class="headerlink" title="4. PSRAM的开启和使用"></a>4. PSRAM的开启和使用</h5><h5 id="5-指定默认console输出通道"><a href="#5-指定默认console输出通道" class="headerlink" title="5. 指定默认console输出通道"></a>5. 指定默认console输出通道</h5><p>​		这里面有几个值可以选择：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default:UART0: 		选择系统默认底串口0作为log是输出。</span><br><span class="line">USB CDC:			选择USB CDC设备作为输出，基于TinyUSB</span><br><span class="line">USB serial/JTAG:	选择系统底USB转串口/JTAG接口作为输出。</span><br><span class="line">Custom:UART:		选择系统指定串口作为输出，可以选择UART0/UART1</span><br><span class="line">None:				关闭输出通道，注意，如果这里关闭，但是实际有prinf，可能会报错，</span><br><span class="line">					如果只是希望关闭log,可以参考6，关闭log</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111801417.png" alt="menuconfig_console"></p>
<h5 id="6-设置log输出模式"><a href="#6-设置log输出模式" class="headerlink" title="6. 设置log输出模式"></a>6. 设置log输出模式</h5><p>​		log输出包括两个部分底输出，一个式Bootloader config底log输出，也就是系统启动底时候Bootloader代码底log输出，一个代码的log输出，一般情况下我们只需要设置代码底log输出即可，Bootloader的log输出对我们代码几乎没有影响，还可以方便看到一些代码的配置信息，所以一般不需要设置，保持默认就好。这里把两个都给出来</p>
<p>​		Bootloader的log输出设置：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111802038.png" alt="boot_log"></p>
<p>​		代码的log输出设置：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111802970.png" alt="app_log"></p>
<h4 id="2-关于Kconfig-projbuild和sdkconfig-defaults"><a href="#2-关于Kconfig-projbuild和sdkconfig-defaults" class="headerlink" title="(2). 关于Kconfig.projbuild和sdkconfig.defaults"></a>(2). 关于Kconfig.projbuild和sdkconfig.defaults</h4><p>​		Kconfig.projbuild本质上是一个配置menuconfig的配置文件，可以同来配置和增加menuconfig相关的配置信息。</p>
<p>​		关于Kconfig更多的信息可以参考如下图片：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111803239.png" alt="Kconfig_i"></p>
<p>​		而sdkconfig.defaults可以定义一些默认的配置选项，即给menuconfig配置中的一些参数进行设定，这样可以使得我们不需要通过menuconfig交互式界面对设备信息进行配置，直接通过文本的形式进行配置（前提是我们已经知道了配置的名称和内容）。</p>
<p>​		实际上，我们在执行idf.py menuconfig的时候，会自动根据menuconfig中的定义，加载sdkconfig.defaults的内容，进行配置。所以如果sdkconfig.defaults中的定义已经存在，则会自动进行menuconfig的配置。</p>
<h4 id="3-组件管理-managed-components与components-与官方组件管理工具：-https-components-espressif-com"><a href="#3-组件管理-managed-components与components-与官方组件管理工具：-https-components-espressif-com" class="headerlink" title="(3). 组件管理(managed_components与components)与官方组件管理工具： https://components.espressif.com/"></a>(3). 组件管理(<code>managed_components</code>与<code>components</code>)与官方组件管理工具： <a href="https://components.espressif.com/">https://components.espressif.com/</a></h4><p>​		idf的组件分为三种：idf官方组件， 第三方组件， 自定义组件，它们分别在“idf的frameworks库的components目录”， 工程的<code>managed_components</code>目录， 工程的<code>components</code>目录下，这里对这三个组件做个简单介绍</p>
<p>​		第一种为：idf官方组件，它跟随idf的发布而更新，在idf的frameworks库的components目录下，比如5.1版本的官方组件都在如下目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frameworks\esp-idf-v5.1\components</span><br></pre></td></tr></table></figure>

<p>​		第二种为：第三方组件：一般指的是在官方组件管理工具： <a href="https://components.espressif.com/">https://components.espressif.com/</a> 中可以搜索到的组件库，乐鑫有一个网络组件管理工具网站，在idf中也构建了组件管理工具。官方和某些第三方发布的组件可以在这里搜索到。它可以通过idf_component.yml来管理，一般情况下，在组件库的界面中会提供下载组件的方法如下图：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405111803465.png" alt="components"></p>
<p>​		更新完成之后组件库会自动添加到工程的<code>managed_components</code>目录下方。该组件在每次编译的时候会自动同步，以确保组件内容没有被修改，所以一般不允许修改组件的内容。</p>
<p>​		第三种为：自定义组件，自定义组件库，我们一般放在工程目录的<code>components</code>目录下，用户可以自行修改，另外如果我们要对一些第三方组件进行修改定制，可以线同步到&#96;&#96;managed_components<code>目录，然后我们在剪贴到</code>components&#96;&#96;&#96;目录下，再进行编辑使用。</p>
<h4 id="4-组件配置文件idf-component-yml-和组件信息文件dependencies-lock"><a href="#4-组件配置文件idf-component-yml-和组件信息文件dependencies-lock" class="headerlink" title="(4). 组件配置文件idf_component.yml 和组件信息文件dependencies.lock"></a>(4). 组件配置文件idf_component.yml 和组件信息文件dependencies.lock</h4><p>​		<code>idf_component.yml</code>文件是一个YAML格式的文件，用于定义组件的元数据和依赖关系。这个文件通常位于组件的根目录下，作用包括：</p>
<ul>
<li><strong>定义依赖项</strong>：它列出了当前组件依赖的其他组件或库，包括这些依赖的版本信息。这有助于确保项目中使用的是兼容的组件版本。</li>
<li><strong>指定组件属性</strong>：比如组件的描述、维护者信息、许可证信息等。</li>
<li><strong>配置选项</strong>：提供对组件内部设置的配置，如使能或禁用特定的功能。</li>
</ul>
<p>​		<code>dependencies.lock</code>文件是一个自动生成的文件，通常在执行项目配置过程（如运行<code>idf.py reconfigure</code>或首次构建项目时）生成。它的主要作用是：</p>
<ul>
<li><strong>锁定依赖版本</strong>：文件中详细记录了项目解析依赖时所确定的具体版本号。这确保了项目的再现性，即不同的开发者或在不同的环境中构建项目时，都将使用相同版本的依赖，避免由于依赖版本变化导致的问题。</li>
<li><strong>依赖解析的结果</strong>：这个文件是项目依赖解析过程的直接产物，它包含了所有必需的、已解析的依赖组件及其版本，确保了构建系统能够获取和使用正确的组件版本。</li>
</ul>
<p><code>idf_component.yml</code>和<code>dependencies.lock</code>的区别</p>
<ul>
<li><strong>用途差异</strong>：<code>idf_component.yml</code>用于声明依赖和组件配置，而<code>dependencies.lock</code>用于锁定这些依赖的具体版本，确保构建的一致性。</li>
<li><strong>更新机制</strong>：<code>idf_component.yml</code>由开发者手动更新，以匹配组件需求和属性；<code>dependencies.lock</code>通常在依赖关系有变化或首次解析依赖时自动更新。</li>
<li><strong>目标用户</strong>：<code>idf_component.yml</code>面向项目和组件开发者，他们需要在这个文件中指定和管理组件的依赖关系；而<code>dependencies.lock</code>主要是给构建系统使用，以保证项目的构建环境和条件的一致性。</li>
</ul>
<p>​		<code>idf_component.yml</code>文件内容大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  espressif/esp_lcd_touch_ft5x06: <span class="string">&quot;^1.0.6&quot;</span></span><br><span class="line">  idf: <span class="string">&quot;&gt;=4.4&quot;</span></span><br><span class="line">  lvgl/lvgl: <span class="string">&quot;~8.3.0&quot;</span></span><br><span class="line">  espressif/zlib: <span class="string">&quot;^1.3.0&quot;</span></span><br><span class="line">  espressif/es8311: <span class="string">&quot;^1.0.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>​		<code>dependencies.lock</code>文件内容大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  espressif/es8311:</span><br><span class="line">    component_hash: eacbe7cb7f6993eb0f439121a56663cdfbf95925e7ddf5d2ed5aa640bed476fd</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      service_url: https://api.components.espressif.com/</span><br><span class="line">      <span class="built_in">type</span>: service</span><br><span class="line">    version: 1.0.0</span><br><span class="line">  espressif/esp_lcd_touch:</span><br><span class="line">    component_hash: d4d8f2dc33205797169a97a02e0d89a8982f59fe0509129b54422052b8522f59</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      service_url: https://api.components.espressif.com/</span><br><span class="line">      <span class="built_in">type</span>: service</span><br><span class="line">    version: 1.1.1</span><br><span class="line">  espressif/esp_lcd_touch_ft5x06:</span><br><span class="line">    component_hash: 97759953d9436a365e9427078c5b04ecce4e6a50f50cf62c68cd6bfa229b812c</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      service_url: https://api.components.espressif.com/</span><br><span class="line">      <span class="built_in">type</span>: service</span><br><span class="line">    version: 1.0.6</span><br><span class="line">  espressif/zlib:</span><br><span class="line">    component_hash: 999ec50086ac1c82b8321d8f540dc9fd10f5622948b935558aa16b4b66e95d9d</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      service_url: https://api.components.espressif.com/</span><br><span class="line">      <span class="built_in">type</span>: service</span><br><span class="line">    version: 1.3.0</span><br><span class="line">  idf:</span><br><span class="line">    component_hash: null</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      <span class="built_in">type</span>: idf</span><br><span class="line">    version: 5.1.0</span><br><span class="line">  lvgl/lvgl:</span><br><span class="line">    component_hash: 948bff879a345149b83065535bbc4a026ce9f47498a22881e432a264b9098015</span><br><span class="line">    <span class="built_in">source</span>:</span><br><span class="line">      service_url: https://api.components.espressif.com/</span><br><span class="line">      <span class="built_in">type</span>: service</span><br><span class="line">    version: 8.3.11</span><br><span class="line">manifest_hash: b2c9ad493b01235aaa12d62f4d6922fb1ee3203b34b14257305de16c9838f577</span><br><span class="line">target: esp32c3</span><br><span class="line">version: 1.0.0</span><br></pre></td></tr></table></figure>

<p>​		下面是几个常用的针对<code>idf_component.yml</code>组件描述符</p>
<h5 id="1-Caret-允许版本在当前主版本号范围内更新。"><a href="#1-Caret-允许版本在当前主版本号范围内更新。" class="headerlink" title="1.  ^ (Caret): 允许版本在当前主版本号范围内更新。"></a>1.  <strong>^ (Caret)</strong>: 允许版本在当前主版本号范围内更新。</h5><blockquote>
<p>​		例如，<code>^1.0.6</code>允许使用1.0.6以上到2.0.0以下的版本。</p>
</blockquote>
<h5 id="2-Tilde-允许次要版本的更新，如果指定了次版本，则只更新补丁版本。"><a href="#2-Tilde-允许次要版本的更新，如果指定了次版本，则只更新补丁版本。" class="headerlink" title="2. ~ (Tilde): 允许次要版本的更新，如果指定了次版本，则只更新补丁版本。"></a>2. <strong>~ (Tilde)</strong>: 允许次要版本的更新，如果指定了次版本，则只更新补丁版本。</h5><blockquote>
<p>​		例如，<code>~8.3.0</code>可以更新到8.3.x的任何版本，但不超过8.4.0。</p>
</blockquote>
<h5 id="3-Greater-Than-or-Equal-To-指定版本必须大于或等于特定版本。"><a href="#3-Greater-Than-or-Equal-To-指定版本必须大于或等于特定版本。" class="headerlink" title="3. &gt;&#x3D; (Greater Than or Equal To): 指定版本必须大于或等于特定版本。"></a>3. <strong>&gt;&#x3D; (Greater Than or Equal To)</strong>: 指定版本必须大于或等于特定版本。</h5><blockquote>
<p>​		例如，<code>&gt;=4.4</code>表示版本必须是4.4或更高。</p>
</blockquote>
<h4 id="5-idf中Cmake配置的一些关键词"><a href="#5-idf中Cmake配置的一些关键词" class="headerlink" title="(5). idf中Cmake配置的一些关键词"></a>(5). idf中Cmake配置的一些关键词</h4><h5 id="1-屏蔽一些不必要的警告"><a href="#1-屏蔽一些不必要的警告" class="headerlink" title="1. 屏蔽一些不必要的警告"></a>1. 屏蔽一些不必要的警告</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-char-subscripts -Wno-maybe-uninitialized&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>set</code>: 这是CMake的命令，用于设置或修改变量的值。</li>
<li><code>CMAKE_C_FLAGS</code>: 这是一个CMake变量，代表用于C语言编译器的编译选项。</li>
<li><code>&quot;$&#123;CMAKE_C_FLAGS&#125;&quot;</code>: 这部分是变量替换，意思是取出<code>CMAKE_C_FLAGS</code>变量当前的值。</li>
<li><code>-Wno-char-subscripts</code> 和 <code>-Wno-maybe-uninitialized</code> 是具体添加到<code>CMAKE_C_FLAGS</code>变量中的编译器选项：<ul>
<li><code>-Wno-char-subscripts</code>：这个选项用来禁止编译器发出警告，当数组下标是char类型时。通常这种情况下，char类型的下标会被隐式转换为整型，某些情况下可能会引发问题或警告。</li>
<li><code>-Wno-maybe-uninitialized</code>：这个选项用来禁止编译器发出警告，当变量可能未初始化时。这可以防止编译器对可能未初始化的使用发出警告，尽管这样做有时可能隐藏实际的编程错误。</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="2-自动扫描文件夹下的C文件自动添加（循环扫描目录以及子目录下的所有c文件）"><a href="#2-自动扫描文件夹下的C文件自动添加（循环扫描目录以及子目录下的所有c文件）" class="headerlink" title="2. 自动扫描文件夹下的C文件自动添加（循环扫描目录以及子目录下的所有c文件）"></a>2. 自动扫描文件夹下的C文件自动添加（循环扫描目录以及子目录下的所有c文件）</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES *.c)</span><br><span class="line">idf_component_register(SRCS <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这可能导致增加或者删除文件，但是cmake并没有发现，导致其没有被编译仅二进制文件的可能性，所以这种情况下，建议增加或者删除文件的时候，可以先clean一下项目，然后再重新编译。</p>
<p>​		另一个常用的实践是尽量避免在配置文件中使用GLOB来指定源文件。可以考虑明确列出所有源文件，虽然这增加了维护成本，但可以提高项目的可预测性。</p>
</blockquote>
<h5 id="3-静态库编译到二进制系统中关键字：WHOLE-ARCHIVE"><a href="#3-静态库编译到二进制系统中关键字：WHOLE-ARCHIVE" class="headerlink" title="3. 静态库编译到二进制系统中关键字：WHOLE_ARCHIVE"></a>3. 静态库编译到二进制系统中关键字：WHOLE_ARCHIVE</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES *.c)</span><br><span class="line">idf_component_register(SRCS <span class="variable">$&#123;SOURCES&#125;</span></span><br><span class="line">                    WHOLE_ARCHIVE</span><br><span class="line">                    INCLUDE_DIRS <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个意思是，有些函数，即使没有被系统调用（比如被main函数，或者中断函数，或者其他函数调用），这些函数仍然需要被编译到二进制文件中，这样做的目的是，一些脚本解析器，本身系统不会调用该函数，但是系统会执行来自外部的命令，或者文件系统中的脚本代码，根据脚本代码的执行情况会产生调用函数的可能性，如果不包含此关键字可能导致，该函数并未被编译到二进制文件中，而导致系统执行失败。</p>
</blockquote>
<h5 id="4-组件依赖关键字：REQUIRES"><a href="#4-组件依赖关键字：REQUIRES" class="headerlink" title="4. 组件依赖关键字：REQUIRES"></a>4. 组件依赖关键字：REQUIRES</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES *.c)</span><br><span class="line">idf_component_register(SRCS <span class="variable">$&#123;SOURCES&#125;</span></span><br><span class="line">                    WHOLE_ARCHIVE</span><br><span class="line">                    INCLUDE_DIRS <span class="string">&quot;.&quot;</span></span><br><span class="line">                    REQUIRES</span><br><span class="line">                	driver</span><br><span class="line">                	fatfs)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>REQUIRES关键字描述的是代码对一些其他组件库的依赖关系，也就是说，这部分代码可能需要依赖一些其他组件库一起运行（包括官方组件，第三方组件，自定义组件）如果没有相关的组件，可能会导致编译失败，加上这个组件库之后，系统会把需要的组件库一起添加到系统的编译选项里面进行编译。</p>
</blockquote>
<h5 id="5-添加预处理器定义"><a href="#5-添加预处理器定义" class="headerlink" title="5. 添加预处理器定义"></a>5. 添加预处理器定义</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add macro</span></span><br><span class="line">idf_build_set_property(</span><br><span class="line">    COMPILE_DEFINITIONS <span class="string">&quot;-DPIKA_CONFIG_ENABLE&quot;</span> APPEND)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这会将<code>PIKA_CONFIG_ENABLE</code>定义添加到当前目标的编译定义中。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>ESP32学习笔记</category>
      </categories>
      <tags>
        <tag>esp32</tag>
        <tag>esp-idf</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库</title>
    <url>/articles/modbus_0001.html</url>
    <content><![CDATA[<p>该项目的演示视频，详见：</p>
<p>​	GitHub仓库： <a href="https://github.com/SenySunny/modbus_rt.git">https://github.com/SenySunny/modbus_rt.git</a> </p>
<p>​	Gitee仓库： <a href="https://gitee.com/SenySunny/modbus_rt.git">https://gitee.com/SenySunny/modbus_rt.git</a></p>
<p>​	B站介绍视频和教程：<a href="https://www.bilibili.com/video/BV1cc411m72m/">https://www.bilibili.com/video/BV1cc411m72m/</a></p>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>​		modbus_rt是一款完全基于C语言实现的可以运行在windows, linux,  macos， RTOS上的modbus通信库。主要目的是针对控制系统和工业物联网的方向使用。modbus_rt可以同时支持slave模式和master模式，基于类似socket句柄的实现思想，可以很方便的支持多例模式。它不仅仅是modbus协议的解析和实现，而是尽可能的在应用层做好实现和封装，做到开箱即用，而不需要做过多的应用层移植。</p>
<p>​		modbus_rt支持几乎市面上常用的所有的modbus协议的实现，包括<strong>modbus RTU</strong>，<strong>modbus ASCII</strong>，<strong>modbus TCP</strong>，<strong>modbus TCP over UDP</strong>，<strong>modbus RTU over TCP&#x2F;UDP</strong>, <strong>modbus ASCII over TCP&#x2F;UDP</strong>，且都可以运行在<strong>Slave模式</strong>和<strong>Master模式</strong>。另外modbus_rt提供了modbus通信中的大小端转换函数接口(市面上<strong>4种大小端模式</strong>均支持)，实现不同平台下的modbus寄存到各种数据的转换接口函数功能（包括bytes, string, int, long, float, double等）。</p>
<p>​		modbus_rt还额外提供了基于pikapython的接口实现，并整合进pikapython的官方的包管理器。可以采用python脚本实现modbus通信功能。可以无缝兼容到pikapython的环境当中（后续可能考虑提供基于micro python和Cpython的接口实现，本人对micro python和Cpython的底层封装不是很熟悉，看情况，不一定有时间，感兴趣的可以自己移植）。</p>
<p>​		另外由于modbus_rt采用纯C编写，后续会考虑支持编译封装为动态链接库，供其他编程语言调用（主要考虑给C#调用，目前主要的控制上位机平台基于QT或者C#居多），目前暂时没有封装dll，所以仅提供基于QT的demo。</p>
<h4 id="1、-modbus-rt的主要特性如下："><a href="#1、-modbus-rt的主要特性如下：" class="headerlink" title="1、 modbus_rt的主要特性如下："></a>1、 modbus_rt的主要特性如下：</h4><ol>
<li>可以无缝运行在市面上绝大部分平台，包括：windows，Linux，嵌入式RTOS系统当中（计划会维护rt-thread和FreeRTOS系统）。</li>
<li>采用线程实现应用层接口，可以快速实现多个modbus 实例应用。支持几乎所有的modbus协议，且均支持Slave模式和Master模式。</li>
<li>同时支持市面上4种不同模式的大小端数据转化接口，实现不同平台下的modbus寄存到各种数据的转换接口函数功能（包括bytes, string, int, long, float, double等）。</li>
<li>基于面向对象的思维方式，采用句柄模式，非常方便实现modbus的多例模式。理论上只要性能，内存和空间足够，可以创建无数个modbus实例。</li>
<li><strong>modbus master在tcp模式下支持断线重连功能（包括tcp master和rtu&#x2F;ascii master over tcp）</strong>。在modbus的网络通信中，由于slave是服务端，master为客户端，可能由于网络或者服务端的原因（有些服务端为了保证性能是会自动做短链接处理。就是每进行一次modbus通信之后，会主动断开与客户端的连接，以减小性能开销）。这种情况下，会出现master每次通信需要判断服务端有没有断开，如果断开则需要重新建立连接。modbus_rt内部支持断线重连机制，即使由于网络或者服务端原因断开了连接，下次通信不需要重新建立连接。直接调用功能函数即可，应用框架会自动进行重连（内部有功能调用时重连和定时重连两方面处理，定时重连可以通过宏定义打开或者关闭——针对具有自动断开机制的服务端系统，可以考虑关闭定时重连，否则服务端断开之后系统会间隔的尝试与服务器进行重连。针对其他应用，开启定时重连的目的时为了防止由于网络或者超时原因导致的断开，系统会自动进行重连）。</li>
<li><strong>基于UDP通信接口之上modbus模式下，提供了网络设备查找和发现功能</strong>。即：modbus slave端（一般可以称为设备端，以下简称设备端）与modbus master端（一般PC客户端或者应用端，以下简称客户端）为同一个路由器或者交换机下面的不同设备时。即使设备端与客户端的IP地址不在同一个网段下（设备端IP地址未知），可以由客户端通过往255.255.255.255的广播地址广播modbus命令，设备端收到广播信息后会对广播设备的ip地址进行检测，如果与设备不在同一个网段，会默认往255.255.255.255广播应答信息。这个时候，客户端就可以获取到modbus_rt设备端的ip地址。这样就可以实现设备地址的发现。另外基于此基础上可以扩展实现修改设备的IP地址的功能（详细可以参考rt-thread平台演示）。</li>
<li><strong>mdobus_rt在slave模式下，增加了set_pre_ans_callback和set_done_callback两个回调函数调用接口</strong>。方便快速实现modbus协议与其他协议的转换。比如modbus RTU，ASCII，TCP之间的相互转化， modbus转mqtt，modbus转sql， modbus转OPC Client， modbus转profibus，modbus转canOpen等协议（第三方协议需要自己实现）。可以快速实现类似DTU的应用，以适应各种工业物联网的应用需求（详细可以参考modbus dtu案例演示）。</li>
<li><strong>modbus_rt提供脚本的应用层接口API，目前实现基于pikapython</strong>（主要是考虑到pikapython本身采用python3语法，且支持windows，linux，RTOS，甚至无系统的跨平台支持），并且支持脚本解析运行模式和字节码运行模式，且提供了REPL的交互式运行模块。所以可以无缝集成到系统当中，也可以采用类似终端的方式，基于REPL的命令行模式来验证功能。</li>
<li><strong>（2024-01-31增加）支持自动modbus功能码实现文件下载和上传功能</strong>：可以方便的用modbus_rt实现固件升级和其他文件（比如pikapython的字节码）下载上传功能。并且可以选择使用mbedTLS对固件和文件进行加密，实现加密的文件下载和上传。</li>
</ol>
<h4 id="2、-modbus-rt的几点补充说明："><a href="#2、-modbus-rt的几点补充说明：" class="headerlink" title="2、 modbus_rt的几点补充说明："></a>2、 modbus_rt的几点补充说明：</h4><ol>
<li>modbus_rt的协议解析部分基于开源的agile_modbus协议栈修改而来。针对slave_util部分做了重写，主要是支持动态绑定slave寄存器，甚至可以运行中增加slave寄存器。</li>
<li>在基于windows，linux（理论上也可以运行在macos系统）上的串口通信部分采用了开源的libserialport串口通信库，采用加载动态链接库的形式调用，RTOS部分串口通信代码为自己编写。</li>
<li>modbus_rt的网络通信部分，采用BSD Socket接口，所以理论上只要可以支持BSD Socket的平台都可以使用，需要注意的是：为了实现多个socket的阻塞问题，采用了IO多路复用接口（select机制），所以需要系统支持select接口。windows和linux本身就都支持，RTOS系统需要确保系统已经移植了BSD socket并且支持select。</li>
<li>modbus_rt的应用实现层采用多线程，在windows，linux，macos等操作系统上采用了pthread多线程。linux和macos默认支持pthread，windows需要自己加载和安装pthread库。</li>
<li>本项目参考和借鉴使用了包括但不仅限于以下开源的项目：agile_modbus,  libserialport, PikaPython, PikaPython-OpenHardware, RT-Thread, FreeRTOS等等(如还有没有标注的项目，请注明)。采用和借鉴了的开源项目地址详见最后感谢栏，欢迎大家点赞相互交流学习。感谢以上的开源项目作者。</li>
</ol>
<h3 id="二、重大的更新记录"><a href="#二、重大的更新记录" class="headerlink" title="二、重大的更新记录"></a>二、重大的更新记录</h3><h4 id="1、2024-03-01更新内容"><a href="#1、2024-03-01更新内容" class="headerlink" title="1、2024-03-01更新内容"></a>1、2024-03-01更新内容</h4><ol>
<li>修复了modbus_rt在slave模式下，如果绑定寄存器乱序绑定modbus slave寄存器的时候会导致链表数据丢失。（之前测试都是按照从小到大，或者从大到小，没有测试全面，如果地址顺序是乱的，则会出错，最新版本已经修复）——感谢网友“皓月”发现bug。</li>
<li>增加了modbus_rt在freeRTOS系统的支持，并提供了在ESP32和air780e硬件平台的demo示例。</li>
<li>增加了cmsis_rtos2的RTOS兼容层的platform接口移植（并提供了基于freertos的cmsis_rtos2的兼容层）。该接口由网友“皓月”提供并移植验证。本人暂时没有验证，针对非rt-thread或则freeRTOS的用户，可以尝试使用cmsis_rtos2的兼容层使用。本人后续抽空验证之后，会提供验证的demo示例。</li>
</ol>
<h4 id="2、2024-01-31更新内容"><a href="#2、2024-01-31更新内容" class="headerlink" title="2、2024-01-31更新内容"></a>2、2024-01-31更新内容</h4><ol>
<li><p>把SLAVE_DATA_DEVICE_BINDING宏定义，修改为SLAVE_DATA_DEVICE_BINDING宏定义和dev_binding标志变量共同决定是否需要把SLAVE的硬件外设绑定到寄存器当中。所以在设备需要绑定硬件外设时，需要额外调用 modbus_xxx_set_dev_binding(xxx_modbus_device_t dev, int flag)函数来实现绑定变量，否则默认为不绑定，可以作为完全独立的modbus实例存在。这样做的目的是为了在交互端，PC上基于DTU的代码可以几乎不用移植的在嵌入式设备上运行。</p>
</li>
<li><p>增加基于modbus的添加文件传输功能（类似tftp，采用mosbus自定义功能码实现，功能码可以在mosbus_p2p.h中自行修改），可以用该功能实现固件升级(可选择加载加密代码实现固件的加密传输和升级)。另外可以实现串口，网络直接传输pikapython的字节码到设备端（如果设备端有文件系统支持），设备端直接运行字节码，使得在设备端运行pikapython更加高效和便捷。（该功能可以通过宏定义打开或者关闭，关闭文件传输功能，与之前版本兼容）。</p>
</li>
<li><p>整合到pikaPython的官方仓库，可以直接使用pikaPython的包管理工具加载和更新。并且对大小端转化、RTU和TCP做了分割，方便只需要使用Modbus TCP或者只需要使用modbus RTU的用户，也可以快速modbus_rt到项目中（需要RTOS或者操作系统支持，暂时不支持裸机运行modbus_rt）。</p>
</li>
<li><p>把modbus中的协议解析部分，与agile modbus同步更新到1.1.4版本的agile modbus</p>
</li>
<li><p>example中的案例暂时还未同步更新，后续抽空会同步更新到最新版本。</p>
<blockquote>
<p><strong>需要特别注意的是：</strong> 考虑到第1条可能会导致部分使用之前版本代码的用户（仅限在设备端，绑定了硬件本身的IO外设的情况下）在升级到最新版本之后，可能会有一定的兼容性问题（需要在创建modbus slave实例之后，除开需要把宏定义SLAVE_DATA_DEVICE_BINDING设置为1打开，还需要增加额外增加一条modbus_xxx_set_dev_binding函数，才可以实现完全的与硬件绑定功能）。如果不需要以上功能的用户可以直接使用发布的betaV0.1版本。（推荐还是使用最新版本，毕竟有些小Bug最新版本做了更新和修复，所以betaV0.1版本，仅限已经使用了该通信库，且没有额外需求，防止更新导致不兼容的小伙伴。）</p>
</blockquote>
</li>
</ol>
<h3 id="三、测试与使用"><a href="#三、测试与使用" class="headerlink" title="三、测试与使用"></a>三、测试与使用</h3><h4 id="1、-windows平台"><a href="#1、-windows平台" class="headerlink" title="1、 windows平台"></a>1、 windows平台</h4><p>​		windows平台我们这里我们采用QT+MSVC来编译进行测试（理论上用Visual Studio—本身就是基于MSVC，或者MiniGW—基于GCC都可以），我们提供了两个demo：modbus_rt_slave_test和pikapython_test。</p>
<ol>
<li>modbus_rt_slave_test测试程序会运行三个modbus示例，分别为modbus rtu slave， modbus tcp slave和modbus tcp slave over udp。我们可以通过任意一种modbus与其进行通信，这里我们直接用第二个案例pikapython_test来测试（当然也可以用其他软件或者设备进行通信，比如：modbus poll软件）。直接用QT打开工程修改电脑上的串口号和电脑所用网卡的ip地址，编译即可。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753109.png" alt="slave_demo_qt"></p>
<ol start="2">
<li>一、介绍</li>
</ol>
<p>这里我们简单测试用pikapython_test程序，运行<code>rtu_master.py</code>、<code>tcp_master.py</code>、<code>udp_master.py</code>来进行基本功能测试，详细测试方法可以参考演示视频（这里就不赘述了）：</p>
<p>​		我们也可以基于pikapython_test左更多的功能，可以参考后面的案例。</p>
<p>​		如果需要编译到自己的应用程序中，只需要把src目录的代码复制到工程当中去，安装pthread库和libserialport库，自己添加好头文件即可，可以参考我们提供的两个QT+MSVC的源码工程。</p>
<h4 id="2、Linux平台"><a href="#2、Linux平台" class="headerlink" title="2、Linux平台"></a>2、Linux平台</h4><p>​		Linux平台硬件理论上只要时标准的linux系统都可以使用。这里我采用了野火的鲁班猫1作为测试平台，基于瑞芯微（Rockchip）的RK3566平台。主要是手头刚好又这个开发板，而且而且目前市面上很多ROS机器人系统都采用了这块开发板，具有一定的代表性，modbus_rt时上层的应用开发API，所以实际上与硬件无关。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753709.png" alt="lubancat1"></p>
<p>​		linux系统我们提供了和Windows功能一样的两个demo。我们直接编译即可运行。由于linux环境搭建可能针对初学者有些难度，这里简单简述以下编译环境的构建和编译过程。详细的测试方法可以参考演示视频，视频中我们提供了一个案例，就是用两个USB转485的线分别连接windows和linux。然后进行相互通信测试。</p>
<p>​		这里我们刷了野火提供的最新的debian桌面版本的固件。确保安装了git, cmake和gcc程序，如果没有安装可以通过<code>sudo apt install cmake</code> 和<code>sudo apt install git</code>来安装（由于我的开发板系统安装在EMMC中，而flash空间不够，所以代码是在tf卡中编译的，我把tf卡挂载到了<code>/home/cat/sdcard</code>目录下，需要注意给<code>/home/cat/sdcard</code>目录操作权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/mmcblk1 /home/cat/sdcard</span><br><span class="line">sudo chown -R cat /home/cat/sdcard</span><br><span class="line">chmod -R 755 /home/cat/sdcard</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果要在linux下编译libserialport，还需要安装autotools相关工具，因为libserialport是在linux下是基于autotools工具编译的，如果需要编译libserialport下面的example示例，可能还需要安装pkg-config工具。请更具提示安装对应的编译工具</p>
</blockquote>
<ol>
<li>下载libserialport和modbus_rt的源代码，libserialport的地址详见最后的参考的项目地址中。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/sigrokproject/libserialport.git</span><br><span class="line">git clone https://github.com/SenySunny/modbus_rt.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装autotools工具和pkg-config工具</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autotools-dev autoconf automake libtool</span><br><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译和安装libserialport库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd libserialport/</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure </span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果需要运行libserialport下的案例，可以进入examples目录下，执行make编译。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd examples/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>   ​	 此时你可以运行案例，比如以下是运行<code>./list_ports</code>的结果，显示由两个串口，一个是系统调试串口，一个是我外界的USB转串口模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat@lubancat:~/sdcard/libserialport/examples$ ./list_ports </span><br><span class="line">Getting port list.</span><br><span class="line">Found port: /dev/ttyFIQ0</span><br><span class="line">Found port: /dev/ttyUSB0</span><br><span class="line">Found 2 ports.</span><br><span class="line">Freeing port list.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编译和运行modbus_rt(注意编译前线修改代码中的ip地址和串口号等信息)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/modbus_rt_slave_test</span><br><span class="line">sh make.sh</span><br><span class="line">sudo build/modbus_rt_linux </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果要运行pikapython_test案例，编译方法一样，</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/pikapython_test</span><br><span class="line">sh make.sh</span><br><span class="line">sudo build/modbus_rt_linux </span><br></pre></td></tr></table></figure>

<p>​			或者进入目录运行特定的文件，例如下面即直接运行目录下的test.py文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">sudo ./pikapython test.py </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>可以运行和测试modbus_rt相关功能</li>
</ol>
<p>​		测试方法和windows一样，需要注意的是，linux终端和windows略有不同，windows的终端可以直接输入程序名称运行程序，而linux终端输入程序名称会检测环境变量下的有没有该名称的程序，并不会直接运行目录下的程序，所以需要输入<code>.\pikapython</code> 或者运行<code>.\pikapython xxx.py</code>运行程序，另外，如果程序中socket用到了1024以下的端口号，比如modbus默认的502，需要用管理员模式运行，需要输入<code>sudo .\pikapython</code>或者<code>sudo .\pikapython xxx.py</code>运行程序。因为linux系统默认用户不能使用1024以下的端口号。</p>
<blockquote>
<p>还有一点需要注意：如果用windows系统或者linux系统作为设备端使用。开启基于udp的slave模式。希望开启设备IP查找功能，windows系统创建slave设备的时候，需要指定网卡的ip地址，类似windows测试时的“192.168.28.150”。linux系统或者RTOS系统下BSD socket则需要用NULL或者空子字符串“”来指定采用默认IP地址。否则接收不到来自255.255.255.255的广播数据包。</p>
</blockquote>
<h4 id="3、RT-Thread平台"><a href="#3、RT-Thread平台" class="headerlink" title="3、RT-Thread平台"></a>3、RT-Thread平台</h4><p>​		RT-thread平台演示提供了两套硬件，其中一套硬件是自己DIY的一块PLC开发板，考虑到使用者并没有这个板子做验证，另外这个板子的网络部分采用了W5500的网络芯片来实现的，增加了STM32+lan8720A+lwip的案例演示，该开发板基于”野火STM32F407_骄阳开发板“来实现，关于该开发板的资料可以参考”野火资料下载中心：<a href="https://doc.embedfire.com/products/link/zh/latest/mcu/stm32_motor/ebf_stm32f407_jiaoyang/download/stm32f407_jiaoyang.html">https://doc.embedfire.com/products/link/zh/latest/mcu/stm32_motor/ebf_stm32f407_jiaoyang/download/stm32f407_jiaoyang.html</a> “</p>
<h5 id="（1）-基于APM32E103VET6-W5500"><a href="#（1）-基于APM32E103VET6-W5500" class="headerlink" title="（1） 基于APM32E103VET6 + W5500"></a>（1） 基于APM32E103VET6 + W5500</h5><p>​		RT-thread平台演示采用了我之前自己DIY的一块PLC开发板，外壳完全兼容西门子的S7-200的PLC外壳，主控这里采用国产的珠海半导体的APM32E103VET6芯片（基本兼容STM32F103VET6，引脚Pin2Pin兼容，但是RAM时STM32的2倍，128K，STM32只有64K，另外APM32的主频为120Mhz），网络部分采用W5500网络芯片。运行rt-thread系统。电路图和测试代码可以见<code>example\rt-thread\apm32e103vet6</code></p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753732.png" alt="rt-thread_PLC"></p>
<p>​	</p>
<p>​		该硬件有两个RS485接口，我们代码默认靠近网卡的RS485作为终端测试使用，我们连上网线，RS485线缆(一个用于modbus通信，一个用于终端调试)，上电，编译下载到硬件平台之后。我们可以通过modbus poll控制和读取IO的状态，也可以使用前面编译好的windows或者linux应用程序在终端运行modbus master示例，与其通信。</p>
<blockquote>
<p>​		这里对代码做简要的说明，我们创建了三个slave示例，一个用于modbus rtu slave on RS485，一个modbus tcp slave，一个基于modbus tcp slave over udp。其中udp的slave支持设备查找功能。</p>
<p>寄存器分布如下：</p>
<p>0x寄存器：	20000~				: DO输出寄存器</p>
<p>1x寄存器：	10000~				：DI输入寄存器（只读）</p>
<p>3x寄存器：	8000-8007			: 存储设备的基本信息</p>
<p>​						8008-8015	  	：设备的硬件地址(这里便是MAC地址），注意8008存储的式地址长度</p>
<p>​														（这里是6），8009-8011存储的是MAC地址，8012~8015这里没有使用。</p>
<p>​						8016-8025		:	这里存储的是设备的网络信息分别是IP地址，子网掩码，网关地址，</p>
<p>​														首选DNS服务器，备用DNS服务器。每个占用2个地址。</p>
<p>4x寄存器：	2008-2015	    ： 引入MAC地址匹配功能，针对广播修改网络信息功能。定义与8008-8015相同。</p>
<p>​						2016-2027		： 修改网络信息地址寄存器，2016-2025地址分别是IP地址，子网掩码，</p>
<p>​														网关地址，首选DNS服务器，备用DNS服务器，每个占用2个地址。</p>
<p>​														2016为修改确认标识，表示修改哪些信息，可以取值为0~5。</p>
<p>​														默认0不修改，</p>
<p>​																1	表示只传递ip，子网掩码和网关采用默认（子网掩码默认</p>
<p>​																		255.255.255.0，网关地址默认为ip同一网段下的xxx.xxx.xxx.1）;</p>
<p>​																2	表示只传递ip和子网掩码,网关采用默认；</p>
<p>​																3	表示ip，子网掩码和网关同时修改)</p>
<p>​																4	增加修改首先DNS服务器</p>
<p>​																5	所有的信息都修改。</p>
<p>​													2017为开启DHCP模式，设置1则表示开启，仅对当前有效，设置后DHCP获取</p>
<p>​													到的IP地址等网络信息会存储在3x寄存器的8016-8025当中，重启之后，系统</p>
<p>​													会回到静态ip模式，并把上次DHCP的IP作为静态IP来设置，所以该模式作用于</p>
<p>​													在不知道路由器可用IP的情况下让路由自动给设备分配一个ip使用。</p>
</blockquote>
<p>​		该代码和windows和linux的modbus_rt_slave_test功能一致，即运行三个modbus slave实例，分别基于RS485，tcp和udp。其中udp我们增加了网络搜索设备和修改设备网络信息的功能。同时我们基于QT编写了一个查找和修改设备网络信息的上位机程序（本身也是基于modbus_rt），在<code>example\windows\tools\find_device</code>目录下，我们编译程序下载到单片机之后，就可以用这个软件查找和修改设备的IP了（该软件查找设备支持多设备同时查找，但是修改跨网段的设备的网络信息是默认不支持多设备，这里主要的原因是：查找设备是通过广播查找，但是如果发现设备与电脑不在同一个网段，则会通过广播修改网络信息，但是如果发现设备本身和电脑在同一个网段，则会使用定向ip地址发送信息）。</p>
<blockquote>
<p>针对RT-Thread平台代码做了修改，增加了MAC地址匹配功能，这样便支持跨网段的多设备修改功能了（需要注意的是：MAC地址匹配功能不属于modbus_rt应用框架内的功能。需要自己应用端去实现和匹配，且一定要确保MAC具有唯一性，如果多设备的MAC一样，该功能可能会导致问题。最新版本的固件代码已经增加MAC地址匹配功能。）。</p>
</blockquote>
<p>​		目前查找和修改设备IP上位机目前只提供window平台，linux平台暂时未提供，使用方法将建演示视频。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131754984.png" alt="device_find"></p>
<p>软件的简介和使用说明，详见仓库中的[软件说明手册]</p>
<h5 id="（2）-基于STM32F407-lan8720A-lwip"><a href="#（2）-基于STM32F407-lan8720A-lwip" class="headerlink" title="（2） 基于STM32F407 + lan8720A + lwip"></a>（2） 基于STM32F407 + lan8720A + lwip</h5><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131754548.png" alt="stm32f407_jiaoyang"></h6><p>​        这里我们基于野火STM32F407_骄阳开发做了两个demo，demo的功能和windows基于Linux平台的功能一样，这里需要注意的是：</p>
<ol>
<li>第一个demo和基于APM32E103VET6的demo一样，增加了网络设备查找的功能，可以通过”查找和修改设备IP上位机“进行设备发现和修改设备的网络信息。</li>
<li>第二个demo由于是在嵌入式平台运行python代码。考虑的文件的传输，这里利用开发板上的SPI Flash 建立了一个FAT文件系统，把其绑定在USB_DEVICE_MSTORAGE设备上，这样就可以把开发板作为一个U盘来使用了。需要拷贝python文件的时候，直接接入USB设备，文件系统就会挂在到USB_DEVICE_MSTORAGE设备上，这时候可以拷贝和编辑里面的PikaPython的python代码。编辑保存完毕之后断开USB，此时文件系统会直接挂在在FATFS文件系统下面，此时便可以通过MSH的命令行执行相应的python代码。（当然，还有很多其他方式可以实现，比如通过TFTP等协议传输文件，这里只是提供了一个demo示例）</li>
<li>另外，在code_py中增加了一个用STM32实现modbus TCP转RTU的DTU的案例，由于我们在STM32上已经做了寄存器绑定，所以这个demo和在PC上略微有一点不同，代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modbus_rt</span><br><span class="line"><span class="keyword">import</span> modbus_rt_defines <span class="keyword">as</span> cst</span><br><span class="line"></span><br><span class="line">serial_name = <span class="string">&quot;uart4&quot;</span></span><br><span class="line">ip_addr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">rm = modbus_rt.rtu(cst.MASTER)</span><br><span class="line">rm.set_serial(serial_name)</span><br><span class="line">rm.<span class="built_in">open</span>()</span><br><span class="line">ts = modbus_rt.tcp()</span><br><span class="line">ts.set_net(ip_addr, <span class="number">502</span>, cst.SOCK_STREAM)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.READ_DISCRETE_INPUTS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = rm.excuse(slave, function, addr + <span class="number">10000</span>, quantity)</span><br><span class="line">            ts.excuse(cst.WRITE, cst.INPUTS, addr, quantity, data)</span><br><span class="line">    <span class="keyword">elif</span> cst.READ_COILS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = rm.excuse(slave, function, addr + <span class="number">20000</span>, quantity)</span><br><span class="line">            ts.excuse(cst.WRITE, cst.CIOLS, addr, quantity, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.WRITE_SINGLE_COIL == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = ts.excuse(cst.READ, cst.CIOLS, addr, <span class="number">1</span>)  </span><br><span class="line">            rm.excuse(slave, function, addr + <span class="number">20000</span>, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_COILS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = ts.excuse(cst.READ, cst.CIOLS, addr, quantity)  </span><br><span class="line">            rm.excuse(slave, function, addr + <span class="number">20000</span>, quantity, data)  </span><br><span class="line">ts.set_strict(<span class="number">0</span>)</span><br><span class="line">ts.set_pre_ans_callback(pre_call)</span><br><span class="line">ts.set_done_callback(done_call)</span><br><span class="line">ts.<span class="built_in">open</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        该代码执行的效果是，如果写20000线圈寄存器，则默认是写DO输出操作，如果写的是地址0的线圈寄存器，则会默认为通过RTU写扩展IO模块的20000线圈寄存器；同样的，如果是读10000离散输入寄存器，则默认读取的是开发板的DI输入，但是如果读取的是0的离散输入寄存器，则会默认通过RTU读取扩展模块的10000寄存器。这样就方便的对IO外设进行扩展，或者以支持以太网的设备作为主控，以RTU外设作为从机。实现主机对从机的调度。另外通过主机设备像上位机或者云端上传信息的功能。</p>
<h4 id="4、FreeRTOS平台"><a href="#4、FreeRTOS平台" class="headerlink" title="4、FreeRTOS平台"></a>4、FreeRTOS平台</h4><p>​	    FreeRTOS平台，我们针对两款硬件平台做测试，一款是PikaPython的开源硬件 PikaPython-OpenHardware，该硬件基于ESP32-S3平台，我们基于ESP-IDF V5.1版本开发，理论上可以兼容所有采用ESP-IDF的ESP32的设备，该开发板完全开源，板载隔离RS485接口，另外网络部分可以用wifi进行测试，实际上我们可以采用任何一款ESP32系列的开发板和最小系统板运行该实例。开发板的开源仓库为：<a href="https://gitee.com/Lyon1998/pikapython_openhardware">https://gitee.com/Lyon1998/pikapython_openhardware </a>，开发板示意图如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755011.png" alt="PikaPython-OpenHardware"></p>
<p>​	    另外一款平台，我们基于合宙的air780E的4G Cat.1模组，其核心控制器采用移芯的EC618芯片平台，理论上也可以兼容air780EG，air780EP，air780EPV等采用移芯EC618，EC718的模组使用。</p>
<p>​	    我们采用的开发板为开源的pikapython-air780e开发板，其软硬件完全开源，开源仓库为：<a href="https://gitee.com/Lyon1998/pikapython-air780e">https://gitee.com/Lyon1998/pikapython-air780e</a>, 该开发硬件上有隔离RS232，隔离RS485接口，还有其他丰富的扩展模块。开发板的示意图如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755760.jpg" alt="air780e"></p>
<h5 id="（1）-基于ESP32，采用ESP-IDF环境"><a href="#（1）-基于ESP32，采用ESP-IDF环境" class="headerlink" title="（1） 基于ESP32，采用ESP-IDF环境"></a>（1） 基于ESP32，采用ESP-IDF环境</h5><p>​        平台的测试代码仓库（基于idf V5.1开发环境），我们提供了两个demo，一个是运行modbus_rt的demo，一个是运行pikaPython的demo，工程代码在example\FreeRTOS\PikaPython_OpenHardware目录下：</p>
<ol>
<li>首先安装idf开发环境，以及vscode 的idf插件，可以参考如下文档：<a href="https://pikapython.com/doc/board_wireless.html">https://pikapython.com/doc/board_wireless.html </a>, 也可以参考B站的idf开发视频，这里推荐一个视频：<a href="https://space.bilibili.com/1375767826/channel/collectiondetail?sid=846684">https://space.bilibili.com/1375767826/channel/collectiondetail?sid=846684</a></li>
<li>用vscode打开对应的工程文件编译下载即可，这里特别需要注意的是，第一个modbus_rt案例，采用直接写死wifi的ssid和password的形式，如果要修改ssid和password，在vscode中按ctrl+p，在弹出的菜单中输入”&gt;ESP-IDF:SDK Configuration editor (menuconfig)”进入menuconfig界面。选择左侧的Example Connection Configuration选项卡，修改wifi路由器的SSID和密码等参数信息。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755205.png" alt="esp32_wifi"></p>
<ol start="3">
<li>另外，如果你采用的是ESP32-S3芯片，默认的终端调试串口采用USB-UART接口，希望采用uart0来运行modbus_rt的话，可以在menuconfig的配置项目中的Channel for console output选项，选择为USB Serial&#x2F;JTAG Controller，来关闭uart0的默认终端输出功能（如果不关闭，会导致uart0作为console端口与modbus通信冲突）。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755099.png" alt="esp32_console"></p>
<ol start="4">
<li>如果要运行PIKA_PI_WIRELESS_FIRMWARE固件，希望用wifi来运行modbus TCP或者其他基于网络的modbus实例的话，需要确保WiFi已经连接到AP路由上之后再用open函数运行modbus实例，否则，会导致由于网络未连接导致网络的modbus执行失败。</li>
</ol>
<h5 id="（2）-基于air780e，基于C语言，封装pikapython，采用xmake编译"><a href="#（2）-基于air780e，基于C语言，封装pikapython，采用xmake编译" class="headerlink" title="（2） 基于air780e，基于C语言，封装pikapython，采用xmake编译"></a>（2） 基于air780e，基于C语言，封装pikapython，采用xmake编译</h5><p>​        基于air780e的案例，可以直接采用pikapython-air780e官方仓库的代码，目前modbus_rt的实例已经与官方仓库同步。仓库地址：<a href="https://gitee.com/Lyon1998/pikapython-air780e">https://gitee.com/Lyon1998/pikapython-air780e </a>，请按照官方仓库的说明编译和使用。</p>
<p>​        目前的air780e平台，考虑到4G Cat.1模组无局域网环境，暂时只适配modbus RTU和modbus ASCII，并没有适配modbus TCP等网络相关的modbus协议。</p>
<h4 id="5、mosbus-rt与西门子PLC进行通信"><a href="#5、mosbus-rt与西门子PLC进行通信" class="headerlink" title="5、mosbus_rt与西门子PLC进行通信"></a>5、mosbus_rt与西门子PLC进行通信</h4><p>​		因为我们以上4个平台的接口部分都是采用PikaPython封装的API，采用脚本进行通信，所以测试用哪个平台无所谓，西门子PLC我们采用比较常用的S7-1214C的PLC平台，这里仅仅测试modbus TCP，我们提供两个demo：</p>
<ol>
<li>S7-1214C运行modbus TCP master案例，连接到我们rt-thread平台硬件上，把rt-thread开发板作为西门子PLC的扩展modbus IO模块使用。这里我们简单做了一个应用，采样S7-1214C的I0.0作为启动连接到IO的信号，之后把rt-thread开发板的DI输出到DO中，此时我们输入板子的DI，对应的DO就有输出。详细可以参考演示视频。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755684.png" alt="TIA1"></p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758904.png" alt="TIA1"></p>
<ol start="2">
<li>S7-1214C运行modbus TCP slave案例，利用windows或者linux上运行的mobus_rt 运行的master操作西门子PLC的外设（包括I Q IW和自定义的保持寄存器，I对饮的1x寄存器，Q对应的0x寄存器，IW对应的3x寄存器），详细可以参考演示视频。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758492.png" alt="TIA3"></p>
<p>​	PLC工程详见example&#x2F;PLC目录，工程采用博图V15.1创建工程。</p>
<h4 id="6、modbus-rt与组态屏进行通信"><a href="#6、modbus-rt与组态屏进行通信" class="headerlink" title="6、modbus_rt与组态屏进行通信"></a>6、modbus_rt与组态屏进行通信</h4><p>​		威纶通组态屏程序，我们用威纶通的MT8071IP组态屏，结合我们的RT-Thread平台硬件，进行DO控制和DI检测示例。威纶通屏幕的工程详解example&#x2F;WEINVIEW，采用EBproV6.08.02.500打开下载。理论上其他的组态屏操作也基本一致，这里就不一一测试了。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758167.png" alt="MT8071IP"></p>
<p>​		这里我们只是写了一个用威纶通屏幕读取DI并写入DO控制开发板的简易Demo, 监控四路输入和4路输出。组态屏屏本身可以通过modbus实现的功能非常强大，这里就不赘叙了。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758884.png" alt="WEINVIEW"></p>
<h4 id="7、modbus-rt与国产大彩串口屏进行通信"><a href="#7、modbus-rt与国产大彩串口屏进行通信" class="headerlink" title="7、modbus_rt与国产大彩串口屏进行通信"></a>7、modbus_rt与国产大彩串口屏进行通信</h4><p>​		考虑到很多成本敏感的项目或者用户并不会使用组态屏（主要价格贵）。所以这里我们也采用国产的大彩串口屏做了一个demo示例，国产的串口屏性价比就高很多了。大彩串口屏，很多型号都支持modbus协议，价格甚至只需要几十元就可以搞定，这里我们选择了一款2.8寸的串口屏，型号：DC24320M028_1110_0T。我们通过该串口屏实现和组态屏一样的功能，实现对DI的监控和DO的控制。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758911.png" alt="DC24320M028_1110_0T"></p>
<p>​		大彩串口屏的工程见example&#x2F;DACAI，软件采用VisualTFT_3.0.0.1232，界面如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131759002.png" alt="DACAI"></p>
<p>​		由于我采用的大彩串口屏时RS232&#x2F;TTL-UART接口的，所以这里演示的时候采用了TTL-UART，外接了一个TTL转RS485模块，最终接到我们的RT-thread开发板上。</p>
<h4 id="8、mobus-DTU相关示例"><a href="#8、mobus-DTU相关示例" class="headerlink" title="8、mobus DTU相关示例"></a>8、mobus DTU相关示例</h4><p>​		这里做一个简单的示例，实现modbus TCP转modbus RTU功能。我们用Linux系统开发板上接入USB转RS485模块，连接到rt-thread平台硬件上（用来模拟基于modbus rtu的外设——比如IO模块，传感器外设）。然后再windows上运行modbus tcp master，与linux通信，实现对rt-thread平台硬件上的IIO控制。</p>
<p>​	这里主要验证利用modbus_rt的回调函数功能实现dtu转换功能。</p>
<ol>
<li>首先进入linux平台下的build目录：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/pikapython_test/build</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个<code>tcp2rtu_dtu.py</code> 文件，并复制如下代码：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modbus_rt</span><br><span class="line"><span class="keyword">import</span> modbus_rt_defines <span class="keyword">as</span> cst</span><br><span class="line"></span><br><span class="line">serial_name = <span class="string">&quot;/dev/ttyUSB0&quot;</span></span><br><span class="line">ip_addr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">rm = modbus_rt.rtu(cst.MASTER)</span><br><span class="line">rm.set_serial(serial_name)</span><br><span class="line">rm.<span class="built_in">open</span>()</span><br><span class="line">ts = modbus_rt.tcp()</span><br><span class="line">ts.set_net(ip_addr, <span class="number">502</span>, cst.SOCK_STREAM)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.READ_HOLDING_REGISTERS == function: </span><br><span class="line">        data = rm.excuse(slave, function, addr, quantity)</span><br><span class="line">        ts.excuse(cst.WRITE, cst.REGISTERS, addr, quantity, data)</span><br><span class="line">    <span class="keyword">elif</span> cst.READ_DISCRETE_INPUTS == function: </span><br><span class="line">        data = rm.excuse(slave, function, addr, quantity)</span><br><span class="line">        ts.excuse(cst.WRITE, cst.INPUTS, addr, quantity, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.WRITE_SINGLE_COIL == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.CIOLS, addr, <span class="number">1</span>)  </span><br><span class="line">        rm.excuse(slave, function, addr, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_SINGLE_REGISTER == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.REGISTERS, addr, <span class="number">1</span>) </span><br><span class="line">        rm.excuse(slave, function, addr, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_COILS == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.CIOLS, addr, quantity)  </span><br><span class="line">        rm.excuse(slave, function, addr, quantity, data)  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_REGISTERS == function: </span><br><span class="line">        data = ts.excuse(<span class="number">0</span>, cst.REGISTERS, addr, quantity)  </span><br><span class="line">        rm.excuse(slave, function, addr, quantity, data)    </span><br><span class="line">ts.add_block(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, <span class="number">20000</span>, <span class="number">10</span>)</span><br><span class="line">ts.add_block(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, <span class="number">10000</span>, <span class="number">16</span>)</span><br><span class="line">ts.add_block(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">ts.set_strict(<span class="number">0</span>)</span><br><span class="line">ts.set_pre_ans_callback(pre_call)</span><br><span class="line">ts.set_done_callback(done_call)</span><br><span class="line">ts.<span class="built_in">open</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​        我们可以看到，代码主要的功能便是创建一个tcp slave和rtu master，并把其写线圈和保持寄存器的指令转化为对rtu master对外的操作。并在接收到读保持寄存器和离散输入寄存器指令的之后，首先通过rtu master获取对应地址的设备的信息，用来更新自己的寄存器信息，以确保读取到的信息为对用的rtu slave设备的信息。</p>
</blockquote>
<ol start="3">
<li>我们运行对应的<code>.py</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./pikapython tcp2rtu_dtu.py</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>之后我们便可以通过modbus master设备来操作dtu下面连接的rtu slave设备了。</li>
</ol>
<blockquote>
<p>后续根据情况可以陆续提供多种应用demo</p>
</blockquote>
<h3 id="四、接口说明"><a href="#四、接口说明" class="headerlink" title="四、接口说明"></a>四、接口说明</h3><h4 id="1、-移植和使用"><a href="#1、-移植和使用" class="headerlink" title="1、 移植和使用"></a>1、 移植和使用</h4><ol>
<li><p>通过modbus_tcp(mode), modbus_rtu(mode)或者modbus_ascii(mode)创建示例，mode：0表示modbus slave; 1表示modbus Master。该函数主要用于创建设备的数据块内容，设备块内容，初始化设备需要用到的互斥量和信号量。</p>
</li>
<li><p>通过modbus_xxx_set_net，modbus_xxx_set_serial等函数初始化相应的参数,详情见API手册</p>
</li>
<li><p>通过modbus_xxx_open开启运行设备，该函数主要用于 建立设备的通信端口，创建通信相关的线程。</p>
</li>
<li><p>如果暂时不需要使用设备，可以使用modbus_xxx_close函数关闭设备，该函数主要用于结束设备通信相关线程，关闭设备的通信接口</p>
</li>
<li><p>如果彻底不适用对应设备了，可以使用modbus_xxx_destroy销毁该设备，该函数主要用于销毁设备的互斥量和信号量相关数，销毁设备的数据信息和设备信。此时设备指针将指向空指针。</p>
</li>
<li><p>slave添加寄存器数据块函数为modbus_xxx_add_block函数。参数分别为寄存器类型(默认0, 1, 3, 4四种)，寄存器其实地址，存储数据的空间地址，寄存器的长度（不是数据长度）。</p>
</li>
<li><p>获取或者修改寄存器的值用modbus_xxx_excuse函数，针对slave模式为读取或者写入自己的寄存器的值，针对master模式为读取或者写入连接slave设备的寄存器的值。</p>
</li>
<li><p>如果要实现dtu或者modbus与其他协议的转换内容，可以通过modbus_xxx_set_pre_ans_callback和modbus_xxx_set_done_callback设置两个回调函数，分别再slave设备收到master端的数据时调用，和modbus通信结束后调用，可以再回调函数中完成协议转换相关的内容（注意回调函数不能为阻塞函数，否则会导致modbus通信超时）。</p>
</li>
<li><p>如果需要把modbus slave设备与设备接口绑定，比如实现DIDO，PWM， ADC，DAC，电机控制，修改PID参数等外设模块，可以把宏定义modbus_config.h中的SLAVE_DATA_DEVICE_BINDING宏定义修改为1，自己完成硬件外设与slave寄存器的绑定工作。详细操作可以参考RT-thread平台的嵌入式demo。大致的操作如下：</p>
<blockquote>
<p>需要自己添加”device_data.h”头文件和完成以下几个函数：</p>
<p>dev_write_bits：       写bits寄存器</p>
<p>dev_read_bits：       读bits寄存器</p>
<p>dev_write_regs：       写regs寄存器</p>
<p>dev_read_regs：       读regs寄存器</p>
<p>dev_data2modbus_slave：   寄存器初始化（绑定slave寄存器和硬件外设信息）</p>
</blockquote>
</li>
<li><p>modbus_xxx_set_strict用在slave模式下，把strict设置为0则通信不会对master发送的数据的设备地址做匹配检测，即任何地址都可以与该slave设备通信，主要目的在于实现dtu和协议转换相关的功能。</p>
</li>
<li><p>modbus_data_xxx相关函数用于对寄存器与各种数据进行相互转化，以满足不同场景下通信的需求，设备默认为小端模式，由于不同设备的大小端模式不相同。可以采用不同的大小端模式对数据进行转换。</p>
</li>
</ol>
<h4 id="2、-四种大小端模式示例"><a href="#2、-四种大小端模式示例" class="headerlink" title="2、 四种大小端模式示例"></a>2、 四种大小端模式示例</h4><ol>
<li><p>小端模式（Little-endian byte swap）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x20001（131073）</p>
</blockquote>
</li>
<li><p>大端模式（Big-endian byte swap）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x10002000（16,777,728‬）</p>
</blockquote>
</li>
<li><p>内部大段，外部小端（Little-endian）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x2000100（33,554,688‬）</p>
</blockquote>
</li>
<li><p>内部小端，外部大端（Big-endian）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x10002（65538）</p>
</blockquote>
</li>
</ol>
<h3 id="五、-项目参考或者用到的开源项目"><a href="#五、-项目参考或者用到的开源项目" class="headerlink" title="五、 项目参考或者用到的开源项目"></a>五、 项目参考或者用到的开源项目</h3><p>​	本项目参考或者使用了如下开源项目的内容，再此对以下项目的创作者表示感谢。</p>
<ol>
<li><a href="https://github.com/loogg/agile_modbus">agile_modbus(一款开源的支持跨平台的轻量型 modbus 协议栈): https://github.com/loogg/agile_modbus</a></li>
<li><a href="https://github.com/sigrokproject/libserialport">libserialport(一款跨平台的串口库): https://github.com/sigrokproject/libserialport</a></li>
<li><a href="https://github.com/pikasTech/PikaPython">PikaPython(一个完全重写的超轻量级 python 引擎): https://github.com/pikasTech/PikaPython</a></li>
<li><a href="https://gitee.com/Lyon1998/pikapython_openhardware"> PikaPython-OpenHardware(一款验证pikapython的ESP32-S3开发板): https://gitee.com/Lyon1998/pikapython_openhardware</a></li>
<li><a href="https://github.com/RT-Thread/rt-thread">RT-Thread(一款以开源的物联网操作系统): https://github.com/RT-Thread/rt-thread</a></li>
<li><a href="https://github.com/FreeRTOS/FreeRTOS">FreeRTOS(一款微控制器的开源实时操作系统): https://github.com/FreeRTOS/FreeRTOS</a></li>
</ol>
]]></content>
      <categories>
        <category>通信协议</category>
        <category>modbus协议</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>自动化</tag>
        <tag>通信协议</tag>
        <tag>modbus</tag>
        <tag>物联网</tag>
        <tag>PLC</tag>
        <tag>STM32</tag>
        <tag>ESP32</tag>
        <tag>CAT1</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记（一）：git客户端基本使用方法</title>
    <url>/articles/git_0001.html</url>
    <content><![CDATA[<h3 id="1、git的常用基本指令"><a href="#1、git的常用基本指令" class="headerlink" title="1、git的常用基本指令"></a>1、git的常用基本指令</h3><p>​		下面是一些git常用的基本指令集，这里只是简单罗列一下，方便参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置git基本信息</span></span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git仓库初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git克隆仓库</span></span><br><span class="line">git clone https://gitee.com/SenySunny/pikapython.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查当前的工作目录状态（哪些文件被修改了但还没提交）</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加文件，用.表示添加所有文件</span></span><br><span class="line">git add filename</span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂存区的更改提交到本地仓库。通常附带一条消息说明这次提交的内容。</span></span><br><span class="line">git commit -m &quot;Commit message&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地的更改推送到远程仓库，如果是推送到主仓库可以直接用git push来推送</span></span><br><span class="line">git push origin main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库获取最新版本并合并到本地仓库。</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看提交历史，按上下键查看<span class="built_in">log</span>，按q退出<span class="built_in">log</span>模式，或者用git --no-pager <span class="built_in">log</span>直接一次打印所有<span class="built_in">log</span>(尽量少用)</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看未暂存的文件更新了哪些内容。</span></span><br><span class="line">git diff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你想查看系统、全局和本地仓库的所有配置，你可以使用以下命令</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看特定的配置项</span></span><br><span class="line">git config user.email</span><br><span class="line">git config user.name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统级配置（对所有用户有效）：</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看全局级配置（对当前用户有效）：</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地级配置（只对当前仓库有效）：</span></span><br><span class="line">git config --local --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步更新仓库下的分仓库的内容</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>


<h3 id="2、git分支管理与版本维护总结"><a href="#2、git分支管理与版本维护总结" class="headerlink" title="2、git分支管理与版本维护总结"></a>2、git分支管理与版本维护总结</h3><p>​		这里需要特别说明一下；分支管理一般用于在允许你在主开发线上分离一个动态开发线路，主要用来进行新的功能开发，bug调试等工作，主要目的是为了在新功能开发，或者调试bug的同时，不影响主线。分支可以随着新的提交而更新。</p>
<p>​		常用的分支管理指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch               		# 列出所有本地分支</span><br><span class="line">git branch -a            		# 列出所有分支（本地和远程）</span><br><span class="line">git branch new-branch    		# 创建新分支</span><br><span class="line">git checkout new-branch  		# 切换到新分支</span><br><span class="line">git checkout -b new-branch		# 创建并切换分支</span><br><span class="line">git checkout main				# 切换回主线进行开发</span><br></pre></td></tr></table></figure>

<p>​		而版本管理，我们一般用tag指令来处理，Tag通常用来标记特定的点，可以理解为Tag是对某一时刻的提交（commit）的引用。一般用来做版本发布，当软件开发到一个特定节点时，我们可以用tag指令来发布版本。</p>
<p>​		tag常用指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a v1.3 -m &quot;Release version 1.3&quot;</span><br><span class="line">git push origin v1.3</span><br></pre></td></tr></table></figure>

<p>​		一般软件版本为x.x.x三组数据组成，第一个为主版本，第二个版本为功能更新版本，第三个为功能修复和完善的版本。也就是说正常情况下，我们发布1.3版本，后续我们回继续对1.3版本进行维护和优化，创建1.3.x版本。如果要增加或者改变功能，我们回同步创建1.4版本。这样就可以实现对多个版本的同步和维护（一般主版本会在产品有重大更新，或者比较大的重构，导致可能会出现兼容性问题的时候，会更新主版本）。</p>
<p>​		我们现在假设，一款软件，我们已经开发到可以发布1.3版本了。我们会采用tag方式创建和发布1.3版本。一般这个时候，我们同步创建一个分支。用于后续修复和完善该版本。我们操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main							# 切换主线</span><br><span class="line">git tag -a v1.3 -m &quot;Release version 1.3&quot;	# 发布v1.3版本</span><br><span class="line">git push origin v1.3						# 推送v1.3版本到远程仓库</span><br><span class="line">git checkout -b release/v1.3 v1.3			# 从v1.3版本的节点创建分支，并切换到该分支</span><br></pre></td></tr></table></figure>

<p>​		此时如果我们要同步更新主线分支和v1.3分支的话，可以如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main							# 切换主线</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给主线分支开发新功能等操作</span></span><br><span class="line">git checkout release/v1.3					# 切换到v1.3的分支</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此处可以进行修复和完善v1.3的代码</span></span><br></pre></td></tr></table></figure>

<p>​		如果我们希望将对1.3版本的完善和修复同步到主线，有以下两种操作方法：</p>
<ol>
<li>从release&#x2F;v1.3的分支合并修复到main分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main							# 切换主线</span><br><span class="line">git merge release/v1.3						# 合并分支到主线分支</span><br></pre></td></tr></table></figure>

<p>​		这种方法将把1.3维护分支的所有更改都合并到 <code>main</code> 分支，适用于所有更改都需要合并的情况。</p>
<ol start="2">
<li>Cherry-pick 特定的提交，如果我们只是希望把某个特定的修复合并到主线分支，则可以通过git log查看到该修复操作的哈希值内容。然后通过如下操作：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main							# 切换主线</span><br><span class="line">git cherry-pick &lt;commit-hash&gt;				# 将特定的提交合并到主线</span><br></pre></td></tr></table></figure>

<p>​		不管是那种操作，我们都需要使用push把它提交到远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin main						# 如果确定目前处于主线仓库，则直接用git push也可以</span><br></pre></td></tr></table></figure>

<p>​		如果我们认为对1.3版本的修复和完善工作已经到了一个阶段，我们可以发布1.3.1版本，此时我们可以如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout release/v1.3					# 切换到v1.3的分支,确保我们目前处在1.3分支当中</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已经在1.3分支中，则不需要checkout命令</span></span><br><span class="line">git push origin release/v1.3				# 确保分支已经推送更新到远程仓库</span><br><span class="line">git tag -a v1.3.1 -m &quot;Release version 1.3.1&quot;# 发布v1.3.1版本 	</span><br><span class="line">git push origin v1.3.1						# 推送v1.3.1版本到远程仓库</span><br></pre></td></tr></table></figure>

<p>​		当然我们也可以继续基于release&#x2F;v1.3的分支进行操作，后续可以发布1.3.2~1.3.x的版本。同时可以基于main分支，来发布1.4版本，或者发布1.4版本之后，继续创建release&#x2F;v1.4的分支内容，用来修复和维护1.4版本的内容。</p>
<p>​		用如上操作，我们基本上可以使用git来维护软件的各个版本内容了。</p>
<h3 id="3、git中关于二进制文件或者其他非文本类大文件处理方法参考"><a href="#3、git中关于二进制文件或者其他非文本类大文件处理方法参考" class="headerlink" title="3、git中关于二进制文件或者其他非文本类大文件处理方法参考"></a>3、git中关于二进制文件或者其他非文本类大文件处理方法参考</h3><ol>
<li>直接用附件上传的方式，把二进制或者其他大文件压缩或者直接作为文件上传到gitee的附件当中去，点击gitee仓库的统计，下面有附件，点击添加附件，然后把“复制链接地址”，把地址或者地址的快捷方式作为文件提供到仓储当中，这样用户就可以通过地址或者快捷方式直接实现二进制或者大文件的下载。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131549940.png" alt="附件"></p>
<ol start="2">
<li><p>采用Git LFS，但是貌似目前并不是所有的git远程仓库都支持LFS功能，比如gitee的个人版本不支持，只有付费企业版本支持。貌似github&#x2F;gitlab&#x2F;bitbucket都是支持LFS的。所以在使用LFS的时候，请确保git的服务器是否支持GIT LFS，否则可能会导致LFS无效。这里对Git LFS做个简单的介绍</p>
<blockquote>
<p>在创建或者上传大文件时：</p>
<ol>
<li>在仓库中输入<code>git lfs install</code>初始化lfs,如果系统没有lfs插件，git会自动下载lfs插件，并进行初始化。</li>
<li>在现有仓库中使用lfs，你需要指定哪些文件被作为大文件。如下操作：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git lfs track &quot;*.psd&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为了确保仓库的lfs大文件已经被绑定，可以确保<code>.gitattributes</code> 文件被添加到仓库中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br><span class="line">git commit -m &quot;Set Git LFS for psd files&quot;</span><br></pre></td></tr></table></figure>

<p>​		此时，Git LFS来跟踪所有的<code>.psd</code>文件。你可以指定任何文件类型或具体文件。这会创建或修改<code>.gitattributes</code>文件，包含关于哪些文件应由Git LFS跟踪的规则。</p>
<ol start="4">
<li>和正常一样使用git即可</li>
</ol>
</blockquote>
<blockquote>
<p>克隆或者拉取具有lfs的仓库时，如下操作</p>
<ol>
<li>和正常一样下载<code>git clone &lt;repository-url&gt;</code>或者拉取<code>git pull origin main</code>文件即可。如果发现大文件没有被同步，可以尝试用<code>git lfs pull</code>单独拉取一下大文件。</li>
<li>另外可以通过<code>git lfs ls-files</code>来查看哪些文件时由LFS管理的文件。<ol>
<li>如果LFS的对象存储很大，可以尝试使用<code>git lfs prune</code>来同步和清理大文件，这将删除本地存储中的旧版本LFS对象，从而节省空间。</li>
</ol>
</li>
</ol>
</blockquote>
<p>​		可以通过<code>git lfs track</code>来查看哪些文件类型被绑定到lfs大文件存储上了。通过<code>git lfs track &quot;*.psd&quot;</code>来取消某种类型文件的追踪（记得修改完成之后需要push）。</p>
</li>
<li><p>对于一些特别大的文件，或者不经常更改的大型二进制文件，考虑将它们存储在其他地方（如云存储服务），只在Git仓库中保存必要的链接或引用。这个方法和第一个方法基本相同，只是需要自己创建或者寻找第三方的云存储服务而已。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客使用的一些常见问题（一）：外站图片显示，站内链接，嵌入B站视频</title>
    <url>/articles/hexo_0005.html</url>
    <content><![CDATA[<h3 id="1、关于网站使用外网图片无法显示的问题。"><a href="#1、关于网站使用外网图片无法显示的问题。" class="headerlink" title="1、关于网站使用外网图片无法显示的问题。"></a>1、关于网站使用外网图片无法显示的问题。</h3><ol>
<li>如果只需要文章能够正常显示，只需要在文章前面最前方加上如下语句即可：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>​		该方法参考这篇文章的说法：<a href="https://www.cnblogs.com/selier/p/9570650.html%EF%BC%8C">https://www.cnblogs.com/selier/p/9570650.html，</a> 大致的原理是：</p>
<blockquote>
<p>​		一般浏览器向服务器请求一个资源（如图片）时，通常会包括一个<code>Referer</code>头部，它包含了发起请求的页面的URL。这有助于服务器理解请求的来源。</p>
<p>​		而有些图片网站为了防止其它网站盗链其资源（比如我是直接吧图片上传到gitee中，然后再文章中加载）。如果<code>Referer</code>头部显示图片请求来自于非授权的域名，服务器可能拒绝请求。</p>
<p>​		所以该条语句的意思是：告诉浏览器不要发送<code>Referer</code>头部给服务器。这样，图床服务器就无法判断请求是否来自于非授权的域，因而可能“默认”允许请求。</p>
</blockquote>
<p>​		当然如果不想每次创建文章的时候都手动添加该语句，可以尝试把该语句添加到hexo博客更目录下的<code>scaffolds/post.md</code>文件中，该文件是创建文章的模板文件，此时我们通过hexo n “文章题目”的时候会自动添加该语句。</p>
<ol start="2">
<li><p>我在实际的建立博客的时候，可能由图床文件，并不仅仅用在文章中，可能还希望应用到各种页面中，比如主页头像，其他网页内容，这个时候通过向文章头部添加这条语句的方法就不行了，这是我们可以采用hexo的<code>注入器（Injector）</code>往所有的博客页面头部注入该条语句，以实现全网的图片访问。具体做法如下:</p>
<ol>
<li>在hexo博客根目录下添加<code>scripts</code>文件夹，在文件夹中创建<code>injector.js</code>文件，在该文件中添加如下语句：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">injector</span>.<span class="title function_">register</span>(<span class="string">&#x27;head_begin&#x27;</span>, <span class="string">&#x27;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&#x27;</span>, <span class="string">&#x27;default&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>允许<code>hexo cl</code>（清除缓冲）, <code>hexo g</code>（重新生成静态文件）, <code>hexo s</code>(本地启动服务查看效果), <code>hexo d</code>（部署到服务器），来实现网站部署，此时就可以正确的显示了。</li>
</ol>
</li>
</ol>
<h3 id="2、-关于博客内部链接的问题。"><a href="#2、-关于博客内部链接的问题。" class="headerlink" title="2、 关于博客内部链接的问题。"></a>2、 关于博客内部链接的问题。</h3><ol>
<li>把<code>permalink</code>修改为<code>:title/</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://senysunny.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span> <span class="comment"># :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>文章直接做链接，按照<code>/目录/文章名称/</code>作为链接内容即可，会自动链接到<code>网址//目录/文章名称/</code>对应的网页中</li>
</ol>
<h3 id="3、-在博客中嵌入视频（比如B站视频）"><a href="#3、-在博客中嵌入视频（比如B站视频）" class="headerlink" title="3、 在博客中嵌入视频（比如B站视频）"></a>3、 在博客中嵌入视频（比如B站视频）</h3><ol>
<li>直接在markdown中使用<code>&lt;iframe&gt;</code>标签，在标签中添加视频的网址，即可嵌入视频，如下图<iframe  width="100%" height="450" src="//player.bilibili.com/player.html?aid=279747615&bvid=BV1cc411m72m&cid=1365009247&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li>
<li>视频的网址，比如B站的视频，可以在视频下方的分享按钮，有一个嵌入代码，直接复制代码即可，如果嵌入到markdown中，视频比较小，可以在<code>iframe</code>中添加<code>width</code>和<code>height</code>属性，设置视频的宽度和高度，如下所示</li>
</ol>
<pre><code class="yaml">&lt;iframe  width=&quot;100%&quot; height=&quot;450&quot; src=&quot;//player.bilibili.com/player.html?aid=279747615&amp;bvid=BV1cc411m72m&amp;cid=1365009247&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
</code></pre>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>hexo博客系统</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建（三）：部署云端Linux服务器，搭建宝塔Linux面板，实现远程或域名访问。</title>
    <url>/articles/hexo_0003.html</url>
    <content><![CDATA[<blockquote>
<p>​		本文主要讲解如何搭建hexo博客网站，并直接部署在github上，实现通过<code>xxx.github.io</code>来访问博客，同时针对云服务器的用户，可以把Hexo博客同步部署到服务器上，通过宝塔Linux面板架设网站，并实现域名解析和绑定。针对没有云服务器的用户，也给出了直接部署在个人的Linux终端（比如：树莓派或者其他Linux开发板，软路由，NAS等）的方案和思路，并给出通过内网穿透方法实现通过自主域名访问博客的方法。最终实现可以通过<code>xxx.github.io</code>和自主域名访问博客网页。</p>
<p>​		这里不对Hexo博客的特性做说明，详细的Hexo相关的内容，可以参考Hexo官方网站：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>​		这里用宝塔面板主要因为：一方面宝塔面板免去了Nginx的相关配置，可以直接用可视化操作来部署网页；另外一方面，一台Linux服务器可以同属部署多个网站，可以统一用宝塔面板统一管理。也方便该服务器不仅可以用来部署网站，还可以同时作为其他左右使用（比如可以用来做远程代码调试，内网穿透服务等）。</p>
<p>​		本文主要分四个章节来讲解：</p>
<ul>
<li><p>一：<a href="/hexo_0001.html">讲解如何在PC机上搭建Hexo博客，并设置博客主题</a>；</p>
</li>
<li><p>二：<a href="/hexo_0002.html">如何把Hexo搭建的博客同步到github的网页托管服务上，实现以<code>xxx.github.io</code>(其中<code>xxx</code>为你的github用户名)访问</a>；</p>
</li>
<li><p>三： <a href="/hexo_0003.html">如果你有一个具有公网IP的云服务器和已经备案的域名，如何把hexo同时部署到服务器上，实现自主域名的访问</a>；</p>
</li>
<li><p>四：<a href="/hexo_0004.html">如何把博客部署到本地的Linux服务器（树莓派或者其他Linux开发板，软路由，NAS等）上，通过内网穿透服务和自主域名绑定实现实现自主域名的访问</a>。</p>
</li>
</ul>
<p>​		一般情况下，自主域名需要做域名解析，所以，它只能访问你的云服务器或者你本地的Linux服务器，二选一即可，把hexo博客部署在Linux服务器上的操作在第三章节的前面两个部分。</p>
</blockquote>
<h2 id="三、部署Linux服务器，搭建宝塔Linux面板，实现远程或域名访问。"><a href="#三、部署Linux服务器，搭建宝塔Linux面板，实现远程或域名访问。" class="headerlink" title="三、部署Linux服务器，搭建宝塔Linux面板，实现远程或域名访问。"></a>三、部署Linux服务器，搭建宝塔Linux面板，实现远程或域名访问。</h2><blockquote>
<p>​			可能涉及的工具和软件：</p>
<ul>
<li>一台已经安装Linux的云服务器，且有公网IP地址：这里使用的是阿里云ECS云服务器，安装Ubuntu 20.04</li>
<li>ssh终端工具登录软件（Xshell，putty或者MobaXterm等都可以）<ul>
<li>Xshell： <a href="https://www.xshell.com/zh/free-for-home-school/">https://www.xshell.com/zh/free-for-home-school/</a></li>
<li>putty：<a href="https://www.putty.org/">https://www.putty.org/</a></li>
<li>MobaXterm： <a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a></li>
</ul>
</li>
<li>宝塔Linux面板：<a href="https://www.bt.cn/">https://www.bt.cn</a></li>
<li>已经备案的域名（如果云服务器是在国内的话），没有也可以直接用<code>IP:端口</code>来访问（因为国内云服务器默认不允许80端口直接访问）。</li>
<li>无服务静态托管云平台Vercel： <a href="https://vercel.com/">https://vercel.com/</a></li>
</ul>
</blockquote>
<h3 id="1、-Linux系统部署git服务器"><a href="#1、-Linux系统部署git服务器" class="headerlink" title="1、 Linux系统部署git服务器"></a>1、 Linux系统部署git服务器</h3><ol>
<li><p>如果是新的云服务器系统，一般情况下我们首先需要到云服务后台，设置安全组，对常用端口放行，主要有：SSH连接端口：<strong>22</strong>；FTP端口：<strong>20、21、39000-40000</strong>；网站访问端口：<strong>80、443</strong>；phpmyadmin访问端口：<strong>888</strong>；如果还有其他诉求，也需要放行对应端口。如果是本地的Linux系统，则不需要管这些。</p>
<p>​		然后用ssh终端工具登录服务器。一般情况下国内的云服务器安装的Linux系统都会默认已经把软件源修改到国内了，如果是，这一步不需要操作。如果你的系统不是云服务器，或者源并不是国内的，可以用下面方法对软件源进行备份，并且替换到国内的软件源（本文替换的是阿里云的镜像，你也可以替换成其他的镜像）。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.org</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>​		上面的语句是备份软件源的文件，之后便可以编辑修改<code>/etc/apt/sources.list</code>中的软件源地址了，即把里面与<code>ubuntu.com</code>的内容替换成阿里云的源地址即可。</p>
<p>​		一般情况下，默认的源地址ubuntu的官方源：</p>
<p>archive 源（针对X86_64架构）					：<a href="http://archive.ubuntu.com/ubuntu/">http://archive.ubuntu.com/ubuntu/</a></p>
<p>ports   源（针对arm，PowerPC等架构）：<a href="http://ports.ubuntu.com/ubuntu-ports/">http://ports.ubuntu.com/ubuntu-ports/</a></p>
<p>​		或者ubuntu中国官方源</p>
<p>archive 源（针对X86_64架构）					：<a href="http://cn.archive.ubuntu.com/ubuntu/">http://cn.archive.ubuntu.com/ubuntu/</a></p>
<p>ports   源（针对arm，PowerPC等架构）：<a href="http://cn.ports.ubuntu.com/ubuntu-ports/">http://cn.ports.ubuntu.com/ubuntu-ports/</a></p>
<p>​		把对应的内容替换成阿里云镜像即可：</p>
<p>archive 源（针对X86_64架构）					：<a href="https://mirrors.aliyun.com/ubuntu/">https://mirrors.aliyun.com/ubuntu/</a><br>ports   源（针对arm，PowerPC等架构）：<a href="https://mirrors.aliyun.com/ubuntu-ports/">https://mirrors.aliyun.com/ubuntu-ports/</a></p>
<p>​		其他内容可以不变，这里给出一个快速替换网址的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i -e &#x27;s/ports.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>​		这句话的意思是把<code>/etc/apt/sources.list</code>文件中所有的<code>ports.ubuntu.com</code>字符，全部替换为<code>mirrors.aliyun.com</code>，从而实现软件源的替换。</p>
<p>​		另外关于Ubuntu 国内软件源介绍可以参考这篇博客： <a href="https://www.cnblogs.com/Brendon-Tan/p/13236042.html">https://www.cnblogs.com/Brendon-Tan/p/13236042.html</a></p>
<ol start="2">
<li>在终端中输入<code>sudo apt update</code>和<code>sudo apt upgrade</code>来同步和更新系统相关软件。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以通过<code>git --version</code>来查看系统是否安装了git，如果没有，输入<code>sudo apt install git</code>安装git</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确保安装了git之后，我们可以为git服务器创建一个单独的账户。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>

<p>​		其中需要输入2次密码之后，一起其他信息，可以直接输入回车保持默认值。最后输入Y确认创建用户。创建完成之后，可以输入<code>ls /home</code>看是否已经存在一个名为<code>git</code>的文件夹，这个为该用户的默认用户文件夹，如果有，则表示用户创建成功。</p>
<ol start="5">
<li>接下来我们针对git账户配置ssh用户公钥，通过如下代码在<code>/home/git</code>目录下创建<code>.ssh</code>文件夹，并在里面创建<code>authorized_keys</code>文件：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /home/git/.ssh</span><br><span class="line">touch /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>把之前在PC电脑上创建的<code>id_rsa.pub</code>文件内容复制到<code>authorized_keys</code>文件中,具体操作，先用下面指令打开文件，按字母<code>i</code>插入内容，把光标移到文件头，右击鼠标把内容粘贴到文件中，之后按<code>ESC</code>按键，输入<code>:wq</code>保存并退出</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>修改该文件夹和文件的权限，确保git用户有读写目录的权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 775 /home/git/.ssh</span><br><span class="line">chown -R git:git /home/git/.ssh</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在<code>/home/git</code>目录下创建一个git仓库，名称为<code>blog.git</code>，并把其拥有者定义为git用户。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u git git init --bare /home/git/blog.git</span><br><span class="line">cd /home/git</span><br><span class="line">chown git:git -R blog.git</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>创建目录<code>/www/wwwroot/blog</code>目录，用来架设网站服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /www/wwwroot/blog</span><br></pre></td></tr></table></figure>

<p>​			<code>-p</code>的意思，以递归的形式来创建文件夹，如果时递归的形式删除文件夹，则用<code>rm -rf dir_path</code></p>
<ol start="10">
<li>确保git用户有操作该文件夹的权限，如下操作：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R git:git /www/wwwroot/blog</span><br><span class="line">chmod -R 755 /www/wwwroot/blog</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>创建一个git钩子文件，当接收到用户推送过来的文件修改时，把它推送到系统<code>/www/wwwroot/blog</code>目录下，以方便后面用来架设网站。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>​		用上面的指令打开文件，按字母<code>i</code>插入内容，把光标移到文件头，右击鼠标把内容粘贴到文件中，之后按<code>ESC</code>按键，输入<code>:wq</code>保存并退出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git --work-tree=/www/wwwroot/blog --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>

<p>​		然后给该文件设置可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>输入<code>sudo reboot</code>重启系统</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>等待重启完毕之后，我们再次修改PC端hexo博客根目录下的<code>_config.yml</code>文件，这里只需要修改<code>\# Deployment</code>部分内容即可，我们给hexo添加一个git服务器到我们自己的Linux服务器上（注意其中的xxx.xxx.xxx.xxx为你自己服务器的IP地址）：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">    <span class="attr">server1:</span> <span class="string">git@github.com:SenySunny/SenySunny.github.io.git</span></span><br><span class="line">    <span class="attr">server2:</span> <span class="string">git@xxx.xxx.xxx.xxx:/home/git/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li>我们在PC端的终端中输入<code>hexo g</code>来重新生成静态网页， 然后通过<code>hexo d</code>来把生成的网页同时部署到github和我们自己的Linux服务器上，</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>​		如果中间操作有问题，直接用<code>hexo d</code>部署，可能会导致由于没有文件变化，导致并没有进行重新部署，导致没有被正确响应，可以尝试先用<code>hexo cl</code>清除以下缓存，然后再用<code>hexo g</code>重新生成静态网页，再<code>hexo d</code>进行部署，便会把所有的文件都会进行重新部署。</p>
<ol start="15">
<li>此时，我们可以通过<code>ls /www/wwwroot/blog/</code>来查看代码是否被正确的复制到该目录下。如果该目录下有<code>index.html</code>等文件，就证明代码已经被正确的复制, 终端运行效果如下（文件内容根据博客网页情况会略有不同）。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@seny:~/blog.git$ ls /www/wwwroot/blog/</span><br><span class="line">2016  404.html  anzhiyu  archives  css  favicon.ico  img  index.html  js  lib</span><br></pre></td></tr></table></figure>

<h3 id="2、-安装和配置宝塔Linux面板"><a href="#2、-安装和配置宝塔Linux面板" class="headerlink" title="2、 安装和配置宝塔Linux面板"></a>2、 安装和配置宝塔Linux面板</h3><ol>
<li>先输入<code>su</code>,输入管理员密码，以<code>root</code>用户登录，以确保能够获取到系统足够的权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo root</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据系统不同，按照宝塔安装教程安装宝塔Linux面板，本人是ubuntu系统，所以再终端中输入：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec</span><br></pre></td></tr></table></figure>

<p>​		等待面板安装完成，安装可能会提示需要输入<code>y</code>回车确认，安装完成后会给出如下信息：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091716605.png" alt="baota1"></p>
<ol start="3">
<li><p>根据生成的内网面板地址和外网面板地址情况，再浏览器访问宝塔面板。</p>
<ul>
<li>一般情况下，如果是云服务器，我们首先需要再云服务的安全组里面，放行把他面板的端口信息，以确保我们可以正常访问宝塔面板。然后通过外网面板地址进行访问。</li>
<li>如果是本地的Linux系统，我们直接通过内网面板地址进行访问即可。</li>
</ul>
<p>如果提示”您的连接不是私密连接“，直接点击”高级“，选择继续前往即可。然后输入安装完成之后提供的<code>username</code>和<code>password</code>作为用户名和密码进行登录，登录之后，阅读”用户协议“，阅读完成之后，勾选&lt;我已阅读并同意”《用户协议》“&gt;，点击<code>&lt;进入面板&gt;</code>，进入宝塔面板界面。</p>
</li>
<li><p>进入之后，会要求你绑定宝塔账号，目前的宝塔面板，必须注册一个账号，用注册的账号进行登录，登录后界面如下，会给出一个建站需要的软件包安装推荐，因为我们本身是静态网站，所以理论上我们只需要安装<code>Nginx</code>软件即可满足要求，所以理论上我们选择<code>LNMP</code>或者<code>JAVA</code>都包含了<code>Nginx</code>，或者我们关闭它，再手动安装<code>Nginx</code>也是可以的。这里我们直接选择了推荐的<code>LNMP</code>,等待它安装完毕。</p>
</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091735892.png" alt="baota2"></p>
<ol start="4">
<li><p>软件安装完毕之后，我们就可以关闭消息盒子了（也可以关闭等待安装），到这里，宝塔面板就基本安装好了，这里我们对宝塔Linux面板做简单的配置，点击左侧的&lt;面板设置&gt;，既可设置相关信息，主要可能有（其他的可以自行配置）：</p>
<ul>
<li><p>修改登录的用户名和密码，以确保安全。</p>
</li>
<li><p>宝塔面板的端口号，以防止忘记宝塔面板的端口号，注意，如果修改了端口号，需要开放对应的端口信息,通过如下信息，否则可能导致无法访问宝塔面板（一般不建议采用8888，因为用户很容易猜到）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo iptables -I INPUT -p tcp --dport 8888 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>云服务器除要在系统中开放对应端口之外，还需要再安全组中开启对应的端口号</p>
</li>
<li><p>安全入口</p>
</li>
</ul>
</li>
<li><p>点击左侧&lt;网站&gt;选项，选择默认的&lt;PHP项目&gt;（或者&lt;html项目&gt;皆可），点击&lt;添加站点&gt;,按照如图填写：</p>
</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091908646.png" alt="baota3"></p>
<blockquote>
<p>​		这里对填入的信息做简单介绍：</p>
<ul>
<li>域名：我们只是测试hexo博客的访问情况，还没有做域名解析和绑定域名情况，在域名栏中，我们可以输入服务器的IP地址，或者IP:端口号的形式（注意：端口号必须开放访问）</li>
<li>备注：给网站取一个名字，方便我们记住这个网站是干什么的</li>
<li>根目录：就是我们前面部署的存放网站的目录<code>/www/wwwroot/blog</code><ul>
<li>ftp,数据库： 静态网站不需要</li>
<li>PHP版本： 没有用到，选择<code>&lt;纯静态&gt;</code>即可</li>
<li>网站分类： 可以设置，或者默认</li>
</ul>
</li>
</ul>
</blockquote>
<ol start="6">
<li>此时我们在浏览器输入<code>服务器IP</code>或者<code>服务器IP:端口号</code>来访问（有些云服务器，再国内，默认不开放80端口，必须用备案的域名访问。可能就必须用<code>服务器IP:端口号</code>来实现远程访问了），下面是采用开放11000端口之后，用<code>服务器IP:11000</code>访问的接结果：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091930876.png" alt="baota4"></p>
<blockquote>
<p>​		理论上我们可以再任何地点用云服务器的<code>服务器IP:11000</code>来访问该博客。</p>
</blockquote>
<h3 id="3、-域名解析和宝塔面板部署网站"><a href="#3、-域名解析和宝塔面板部署网站" class="headerlink" title="3、 域名解析和宝塔面板部署网站"></a>3、 域名解析和宝塔面板部署网站</h3><blockquote>
<p>​		前面已经讲解网页的部署和安装，如果我们有备案的域名，我们可以把备案的域名与服务器进行绑定，做好域名解析，便可以实现通过网址访问博客。</p>
</blockquote>
<ol>
<li>域名备案，可以再购买域名的网站查看到，比如，这是再阿里云备案的域名情况示意图：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091945640.png" alt="beian1"></p>
<ol start="2">
<li>我们再域名控制台下，可以对域名进行域名解析：如下图：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091948044.png" alt="beian2"></p>
<blockquote>
<p>​		 这里对域名中的几个关键词做说明：</p>
<ul>
<li>记录类型： A： 标志一个IPV4地址；AAA：标志一个IPV6地址；CHANE：将域名指向另外一个域名；其他的具体自己查询</li>
<li>主机记录：www：表示域名前面加www.来访问；@：表示直接用域名访问；*表示泛解析；其他字母：表示该字母.开头的域名访问，比如：如果域名是senysunny.com。解析主机记录为blog。表示用blog.senysunny.com访问。</li>
<li>记录值：一般为IP地址或者另一个域名。</li>
</ul>
</blockquote>
<ol start="3">
<li>做好域名解析之后，我们把对应域名的解析到对应的服务器ip，一般解析之后差不多10分钟左右生效。</li>
<li>此时我们再进入宝塔面板，打开左侧<code>&lt;网站&gt;</code>选项,可以看到我们建立的网站，点击设置，把我们已经做过域名解析的域名填写到域名管理中，点击<code>&lt;添加&gt;</code>按钮。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091959266.png" alt="baota5"></p>
<p>​		此时，我们就可以用我们已经备案的域名来访问我们的博客了。</p>
<blockquote>
<p>​		这里需要提醒的是：中国的域名备案后，一般要求把备案号填写再网页的尾部位置，并链接到”ICP&#x2F;IP地址&#x2F;域名信息备案管理系统“网址： <a href="https://beian.miit.gov.cn.当然,如果你的云服务器本身不在大陆境内,则无需考虑备案事宜,直接做域名解析就可以了./">https://beian.miit.gov.cn。当然，如果你的云服务器本身不在大陆境内，则无需考虑备案事宜，直接做域名解析就可以了。</a></p>
</blockquote>
<p>​		到这里，hexo博客的建立和部署就已经完成了。我们可以发现博客的创建是比较简单的，都是一些基本的操作，hexo博客服务也提供了非常详细的文档。但是一个完整的有自己域名的博客要上线，还需要部署到自己的云服务，以及域名的解析和备案等操作。这些是需要一定的费用和操作的。实际上，我们也有很多其他选择，这里做一个简单的介绍和说明：</p>
<ol>
<li>Vercel：它是一个用于静态站点和无服务器函数的云平台，可以用来部署静态网站项目，并且可以直接与github的网页托管绑定，并且可以与自己注册的域名做域名解析，实现域名访问网站，且服务器本身不在国内，也避免了域名备案的麻烦。</li>
<li>现在很多人会选择把博客部署在本地（比如树莓派等开发板，软路由，NAS）上，在通过各种内网穿透服务，实现外网访问，以及域名绑定的工作。如果内网穿透服务器不在大陆的话，也不需要域名备案。建议购买域名的话还是备案使用更佳。</li>
<li>这里会在下一个章节给出一个把hexo博客部署在本地的Linux服务器（Linux开发板）的解决方案，这里采用了《Nanopi R6S》开发板运行Ubuntu系统作为博客服务器，然后通过内网传统实现博客的访问和使用.</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>hexo博客系统</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Linux</tag>
        <tag>宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建（二）：把hexo博客部署到github网页托管，实现通过类似xxx.github.io来访问博客</title>
    <url>/articles/hexo_0002.html</url>
    <content><![CDATA[<blockquote>
<p>​		本文主要讲解如何搭建hexo博客网站，并直接部署在github上，实现通过<code>xxx.github.io</code>来访问博客，同时针对云服务器的用户，可以把Hexo博客同步部署到服务器上，通过宝塔Linux面板架设网站，并实现域名解析和绑定。针对没有云服务器的用户，也给出了直接部署在个人的Linux终端（比如：树莓派或者其他Linux开发板，软路由，NAS等）的方案和思路，并给出通过内网穿透方法实现通过自主域名访问博客的方法。最终实现可以通过<code>xxx.github.io</code>和自主域名访问博客网页。</p>
<p>​		这里不对Hexo博客的特性做说明，详细的Hexo相关的内容，可以参考Hexo官方网站：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>​		这里用宝塔面板主要因为：一方面宝塔面板免去了Nginx的相关配置，可以直接用可视化操作来部署网页；另外一方面，一台Linux服务器可以同属部署多个网站，可以统一用宝塔面板统一管理。也方便该服务器不仅可以用来部署网站，还可以同时作为其他左右使用（比如可以用来做远程代码调试，内网穿透服务等）。</p>
<p>​		本文主要分四个章节来讲解：</p>
<ul>
<li><p>一：<a href="/hexo_0001.html">讲解如何在PC机上搭建Hexo博客，并设置博客主题</a>；</p>
</li>
<li><p>二：<a href="/hexo_0002.html">如何把Hexo搭建的博客同步到github的网页托管服务上，实现以<code>xxx.github.io</code>(其中<code>xxx</code>为你的github用户名)访问</a>；</p>
</li>
<li><p>三： <a href="/hexo_0003.html">如果你有一个具有公网IP的云服务器和已经备案的域名，如何把hexo同时部署到服务器上，实现自主域名的访问</a>；</p>
</li>
<li><p>四：<a href="/hexo_0004.html">如何把博客部署到本地的Linux服务器（树莓派或者其他Linux开发板，软路由，NAS等）上，通过内网穿透服务和自主域名绑定实现实现自主域名的访问</a>。</p>
</li>
</ul>
<p>​		一般情况下，自主域名需要做域名解析，所以，它只能访问你的云服务器或者你本地的Linux服务器，二选一即可，把hexo博客部署在Linux服务器上的操作在第三章节的前面两个部分。</p>
</blockquote>
<h2 id="二、把hexo博客部署到github网页托管，实现通过类似xxx-github-io来访问博客"><a href="#二、把hexo博客部署到github网页托管，实现通过类似xxx-github-io来访问博客" class="headerlink" title="二、把hexo博客部署到github网页托管，实现通过类似xxx.github.io来访问博客"></a>二、把hexo博客部署到github网页托管，实现通过类似<code>xxx.github.io</code>来访问博客</h2><blockquote>
<p>​		本节讲解如何把在本地PC部署好的博客系统同步到GitHub上，实现可以直接用<code>xxx.github.io</code>来访问你博客，在这里，你首先需要有一个github的账号，这里假设的github的账号名就就是<code>senysunny</code>，到时候你只需要替换你的账户名即可。另外需要说明的是，由于github的服务器在国外，可能会导致你登录和使用GitHub缓慢，这里你可能需要VPN服务实现github的流畅访问，这里不做VPN服务做介绍，正常情况下github国内是可以访问的。</p>
<p>​		本来想着也可以把博客假设到gitee上，但是gitee目前已经停止了<code>gitee pages</code>服务，所以无法实现静态网页的托管服务，这里做一个说明。</p>
<p>​		涉及的工具和软件：</p>
<ul>
<li>github账户：	<a href="https://github.com/">https://github.com/</a></li>
<li>必要情况的下的VPN服务。</li>
</ul>
</blockquote>
<h3 id="1、-把Hexo博客部署到GitHub上"><a href="#1、-把Hexo博客部署到GitHub上" class="headerlink" title="1、 把Hexo博客部署到GitHub上"></a>1、 把Hexo博客部署到GitHub上</h3><ol>
<li>创建一个gtihub的仓库，这个仓库的名称为<code>用户名.github.io</code>。比如，在这里我创建的便是：<code>SenySunny.github.io</code>。注意，需要设置为”Public“，确保用户可以访问。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091250624.png" alt="github1"></p>
<ol start="2">
<li>为 github服务器配置用户公钥，在你的电脑终端中输入<code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code>，然后输入4次回车，如果曾经创建过公钥，可能会提示你是否覆盖，输入Y回车即可。</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;senysunny@163.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>​		实际的效果如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091151802.png" alt="ssh1"></p>
<ol start="2">
<li>此时会在你的电脑<code>C:\Users\用户名</code>目录下有一个<code>.ssh</code>文件夹，里面有一个<code>id_rsa.pub</code>文件，我们可以复制一份出来备份，后面都会用的到，用记事本打开该文件，复制里面的内容。</li>
<li>打开你的github的用户设置界面，选择左侧的<code>SSH and GPG keys</code>菜单，在里面添加一个<code>SSH keys</code>,其中<code>Title</code>可以随机填入，如下图：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091158022.png" alt="ssh2"></p>
<ol start="4">
<li>你可以在终端中输入<code>ssh -T git@github.com</code>测试是否成功，如果成功，会提示<code>You&#39;ve successfully authenticated</code>的字样。</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh <span class="literal">-T</span> git@github.com</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>修改博客根目录下的<code>_config.yml</code>文件，这里只需要修改<code>\# Deployment</code>部分内容即可：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:SenySunny/SenySunny.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果你是第一次使用git，输入以下内容创建一个本地的git账户信息</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git config <span class="literal">--global</span> user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config <span class="literal">--global</span> user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>​		比如我，输入的信息如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git config <span class="literal">--global</span> user.name <span class="string">&quot;SenySunny&quot;</span></span><br><span class="line">git config <span class="literal">--global</span> user.email <span class="string">&quot;senysunny@163.com&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>此时我们重新在终端中输入<code>hexo cl</code>来清除缓存，再通过<code>hexo g</code>来重新生成静态网页， 然后通过<code>hexo d</code>（其为<code>hexo deploy</code>de 缩写）来把生成的网页部署到github上</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>这时，进入我们创建的仓库，就可以看到有内容被添加仓库中了,等待十几秒中之后，我们输入<code>https://senysunny.github.io/</code>就可以访问博客了，这个博客是可以远程访问的，效果如下：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405091255146.png" alt="github2"></p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>hexo博客系统</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建（一）：在PC上搭建Hexo博客系统，并设置博客主题</title>
    <url>/articles/hexo_0001.html</url>
    <content><![CDATA[<blockquote>
<p>​		本文主要讲解如何搭建hexo博客网站，并直接部署在github上，实现通过<code>xxx.github.io</code>来访问博客，同时针对云服务器的用户，可以把Hexo博客同步部署到服务器上，通过宝塔Linux面板架设网站，并实现域名解析和绑定。针对没有云服务器的用户，也给出了直接部署在个人的Linux终端（比如：树莓派或者其他Linux开发板，软路由，NAS等）的方案和思路，并给出通过内网穿透方法实现通过自主域名访问博客的方法。最终实现可以通过<code>xxx.github.io</code>和自主域名访问博客网页。</p>
<p>​		这里不对Hexo博客的特性做说明，详细的Hexo相关的内容，可以参考Hexo官方网站：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>​		这里用宝塔面板主要因为：一方面宝塔面板免去了Nginx的相关配置，可以直接用可视化操作来部署网页；另外一方面，一台Linux服务器可以同属部署多个网站，可以统一用宝塔面板统一管理。也方便该服务器不仅可以用来部署网站，还可以同时作为其他左右使用（比如可以用来做远程代码调试，内网穿透服务等）。</p>
<p>​		本文主要分四个章节来讲解：</p>
<ul>
<li><p>一：<a href="/hexo_0001.html">讲解如何在PC机上搭建Hexo博客，并设置博客主题</a>；</p>
</li>
<li><p>二：<a href="/hexo_0002.html">如何把Hexo搭建的博客同步到github的网页托管服务上，实现以<code>xxx.github.io</code>(其中<code>xxx</code>为你的github用户名)访问</a>；</p>
</li>
<li><p>三： <a href="/hexo_0003.html">如果你有一个具有公网IP的云服务器和已经备案的域名，如何把hexo同时部署到服务器上，实现自主域名的访问</a>；</p>
</li>
<li><p>四：<a href="/hexo_0004.html">如何把博客部署到本地的Linux服务器（树莓派或者其他Linux开发板，软路由，NAS等）上，通过内网穿透服务和自主域名绑定实现实现自主域名的访问</a>。</p>
</li>
</ul>
<p>​		一般情况下，自主域名需要做域名解析，所以，它只能访问你的云服务器或者你本地的Linux服务器，二选一即可，把hexo博客部署在Linux服务器上的操作在第三章节的前面两个部分。</p>
</blockquote>
<h2 id="一、在PC上搭建Hexo博客，并设置博客主题"><a href="#一、在PC上搭建Hexo博客，并设置博客主题" class="headerlink" title="一、在PC上搭建Hexo博客，并设置博客主题"></a>一、在PC上搭建Hexo博客，并设置博客主题</h2><blockquote>
<p>​		设计到的工具和软件：</p>
<ul>
<li><p>Node.js (windows，这里安装的是v18.20.2 LTS版本): 	 <a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a></p>
</li>
<li><p><code>NodeSource</code> 的github网址： <a href="https://github.com/nodesource/distributions">https://github.com/nodesource/distributions</a></p>
</li>
<li><p>git：<a href="https://git-scm.com/">https://git-scm.com/</a></p>
</li>
<li><p>Hexo博客系统： <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
</li>
<li><p>安知鱼博客主题（一款基于Hexo-Butterfly修改的Hexo主题）：<a href="https://docs.anheyu.com/">https://docs.anheyu.com/</a></p>
</li>
<li><p>vscode(编辑文本使用，有需要可以安装)：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
</li>
<li><p>Typora文档编辑器（markdown编辑器，89元终身）：<a href="https://typoraio.cn/">https://typoraio.cn/</a></p>
<p>​		Typora和vscode仅仅是用来作为文章编辑和代码编辑使用，理论上有很多选择，vscode本身也支持markdown编辑功能（通过插件），这里只是给出本人使用的工具而已。关于vscode的安装和使用，可以网络搜索方法，正常情况下直接安装安装包即可，安装后可以安装一个<code>简体中文</code>插件，以方便使用，这里就不赘述了。</p>
</li>
</ul>
</blockquote>
<h3 id="1、-PC机安装hexo博客"><a href="#1、-PC机安装hexo博客" class="headerlink" title="1、 PC机安装hexo博客"></a>1、 PC机安装hexo博客</h3><ol>
<li>针对windows和MAC系统下：Node.js和git直接下载对应的安装包安装即可。安装之后在终端中（CMD终端和PowerShell终端都可以）输入以下命令，确保软件都正确安装：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node <span class="literal">-v</span></span><br><span class="line">npm <span class="literal">-v</span></span><br><span class="line">git <span class="literal">--version</span></span><br></pre></td></tr></table></figure>

<p>​		如果你的是Linux系统（注意：这里的安装hexo博客系统的指的是你的个人电脑，你后续写文章用的电脑，一般情况下这个电脑为windows和mac为主，这里只是提供一个在Linux上安装Node.js的方法），很多Linux系统的源提供的node.js的版本都过于老旧，所以一般Linux系统我们建议用<code>NodeSource</code> 来安装，<code>NodeSource</code> 的官方github的地址在上面说明已经提供，这里假如我们的PC机是Ubuntu，我们需要安装的node版本为v18.20.2 LTS版本，则在终端中输入如下内容 (其他系统在<code>NodeSource</code> 的github网址都有提高安装方法)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - &amp;&amp; sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>

<p>​		git则只需要用标准的包管理器安装即可，ubuntu的安装指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<p>​		安装完成之后和windows与MAC一样在终端中输入以下指令查看是否正确安装以及其版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		如果担心网络问题，后续用npm下载和更新插件导致失败，可以把npm的源修改为国内的源(本文选择的是淘宝npm的镜像)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>​		当然，我们也可以通过如下语句，把镜像源修改为官方的镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry http://www.npmjs.org</span><br></pre></td></tr></table></figure>

<p>​		或者只是临时把镜像源修改为淘宝镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npmmirror.com install node-red-contrib-composer@latest</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​		</p>
<ol start="2">
<li>建立一个文件夹，用来存储博客，比如，我的博客放在的目录为<code>E:\00_blog_senysunny\senysunny</code>，可以直接用vscode打开该目录，开启一个终端，输入<code>npm install hexo-cli -g</code>安装Hexo，安装后，可以在终端界面输入<code>hexo -v</code>查看安装情况：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-cli</span> <span class="literal">-g</span></span><br><span class="line">hexo <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>​		有正确打印hexo的版本信息，例如<code>hexo-cli: 4.3.2</code>则表示安装完成。</p>
<ol start="3">
<li>输入<code>hexo init</code>初始化博客，然后输入<code>npm install</code>安装hexo相关依赖</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>输入<code>hexo g</code>和<code>hexo s</code>，分别式生成静态网页和启动hexo本地服务器的命令缩写，其全称是<code>hexo generate</code>和<code>hexo server</code></li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>此时，你就可以在浏览器打开<code>http://localhost:4000/</code>看到创建的网站了。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405082319800.png" alt="hexo1"></p>
<ol start="6">
<li>测试没有问题，我们可以在终端中按<code>ctrl + c</code>关闭本地服务。为了后续可以把博客同步到github，以及自己的云服务器，可以先安装一个hexo自动部署发布工具。</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="2、安装anzhiyu博客主题"><a href="#2、安装anzhiyu博客主题" class="headerlink" title="2、安装anzhiyu博客主题"></a>2、安装anzhiyu博客主题</h3><blockquote>
<pre><code>             ​		博客已经安装好，但是博客美观还是不行，这里开始给博客安装一个主题，这里安装的是安知鱼的主题，它本身也是基于Butterfly主题修改的。当然，你也可以选择其他主题，不同主题可以参考主题的安装设置文档，这里给出Butterfly和anzhiyu主题的中文文档，可以供参考。实际上我们按照文档一步一步来即可。后续也可以根据文档自己优化自己的博客内容。
         
             Butterfly主题文档中文版： https://butterfly.js.org/posts/21cfbf15/
         
             安知鱼主题文档中文版： https://docs.anheyu.com/initall.html
</code></pre>
</blockquote>
<ol>
<li>输入<code>npm i hexo-theme-anzhiyu</code>安装安知鱼博客主题，并且安装pug 和 stylus 渲染插件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-anzhiyu</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>此时，在博客的目录下会有<code>node_modules\hexo-theme-anzhiyu</code>文件夹，表示已经安装好了主题，我们把该目录下的<code>_config.yml</code>复制到根目录，并修改为<code>_config.anzhiyu.yml</code>（注意根目录下本身就有一个<code>_config.yml</code>两个文件不一样），此时根目录下会有<code>_config.yml</code>和<code>_config.anzhiyu.yml</code>两个文件。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405082358531.png" alt="hexo2"></p>
<ol start="3">
<li>把根目录下的<code>_config.yml</code>的主题修改成<code>anzhiyu</code>，这里顺带把博客的名称、语言、时区等信息一并修改了，如下（下面的内容并不是<code>_config.yml</code>所有内容，只展示了修改的部分,即<code># Site</code>部分和<code># Extensions</code> 部分）：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="type">![hexo3](E:/00_blog_senysunny/img/hexo3.png)</span><span class="type">![hexo3](E:/00_blog_senysunny/img/hexo3.png)#</span> <span class="string">Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">SenySunny</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;SenySunny的技术笔记&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;SenySunny的技术笔记&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">SenySunny</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Seny</span> <span class="string">Lee</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">anzhiyu</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过<code>hexo cl</code>来清除缓存（其为<code>hexo clean</code>的缩写），再通过<code>hexo g</code>和<code>hexo s</code>来重新生成静态网页和启动hexo本地服务器，再次打开<code>http://localhost:4000/</code>可以看到主题已经修改了。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405090009771.png" alt="hexo3"></p>
<ol start="5">
<li>更多的hexo命令可以详细参考：<a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></li>
</ol>
<h3 id="3、安装博客文章加密插件"><a href="#3、安装博客文章加密插件" class="headerlink" title="3、安装博客文章加密插件"></a>3、安装博客文章加密插件</h3><blockquote>
<p>​	本节是属于个人额外补充的内容，如果你写的部分文章，希望再一定时间内暂时加密隐藏，或者说只允许知道访问密码的人观看，可以尝试给博客文件加密，这里用到了一个hexo的encrypt插件，其github的地址为：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt%E3%80%82%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%EF%BC%8C%E8%BF%99%E9%87%8C%E4%BB%85%E4%BB%85%E5%81%9A%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E3%80%82">https://github.com/D0n9X1n/hexo-blog-encrypt。可以参考，这里仅仅做简单介绍。</a></p>
</blockquote>
<ol>
<li>直接输入<code>npm install --save hexo-blog-encrypt</code>安装插件，如果本地服务没有退出，按<code>CTRL + C</code>关闭服务。</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">--save</span> hexo<span class="literal">-blog-encrypt</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>此时，你只需要再文章的头部添加<code> &quot;password&quot;</code>字段即可实现文章的加密，比如下面就是把<code>hello world</code>文章加密，密码为：<code>hello</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2016-03-30 21:18:02</span><br><span class="line">password: hello</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更多的其他功能，可以参考<code>hexo-blog-encrypt</code>的官方文档，官方有提高中文文档，地址已经再本节开头给出。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>hexo博客系统</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建（四）：本地Linux系统部署，搭建宝塔Linux面板，通过内网传统实现域名访问</title>
    <url>/articles/hexo_0004.html</url>
    <content><![CDATA[<blockquote>
<p>​		本文主要讲解如何搭建hexo博客网站，并直接部署在github上，实现通过<code>xxx.github.io</code>来访问博客，同时针对云服务器的用户，可以把Hexo博客同步部署到服务器上，通过宝塔Linux面板架设网站，并实现域名解析和绑定。针对没有云服务器的用户，也给出了直接部署在个人的Linux终端（比如：树莓派或者其他Linux开发板，软路由，NAS等）的方案和思路，并给出通过内网穿透方法实现通过自主域名访问博客的方法。最终实现可以通过<code>xxx.github.io</code>和自主域名访问博客网页。</p>
<p>​		这里不对Hexo博客的特性做说明，详细的Hexo相关的内容，可以参考Hexo官方网站：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p>​		这里用宝塔面板主要因为：一方面宝塔面板免去了Nginx的相关配置，可以直接用可视化操作来部署网页；另外一方面，一台Linux服务器可以同属部署多个网站，可以统一用宝塔面板统一管理。也方便该服务器不仅可以用来部署网站，还可以同时作为其他左右使用（比如可以用来做远程代码调试，内网穿透服务等）。</p>
<p>​		本文主要分四个章节来讲解：</p>
<ul>
<li><p>一：<a href="/hexo_0001.html">讲解如何在PC机上搭建Hexo博客，并设置博客主题</a>；</p>
</li>
<li><p>二：<a href="/hexo_0002.html">如何把Hexo搭建的博客同步到github的网页托管服务上，实现以<code>xxx.github.io</code>(其中<code>xxx</code>为你的github用户名)访问</a>；</p>
</li>
<li><p>三： <a href="/hexo_0003.html">如果你有一个具有公网IP的云服务器和已经备案的域名，如何把hexo同时部署到服务器上，实现自主域名的访问</a>；</p>
</li>
<li><p>四：<a href="/hexo_0004.html">如何把博客部署到本地的Linux服务器（树莓派或者其他Linux开发板，软路由，NAS等）上，通过内网穿透服务和自主域名绑定实现实现自主域名的访问</a>。</p>
</li>
</ul>
<p>​		一般情况下，自主域名需要做域名解析，所以，它只能访问你的云服务器或者你本地的Linux服务器，二选一即可，把hexo博客部署在Linux服务器上的操作在第三章节的前面两个部分。</p>
</blockquote>
<h2 id="四、本地Linux系统部署，搭建宝塔Linux面板，通过内网穿透实现域名访问"><a href="#四、本地Linux系统部署，搭建宝塔Linux面板，通过内网穿透实现域名访问" class="headerlink" title="四、本地Linux系统部署，搭建宝塔Linux面板，通过内网穿透实现域名访问"></a>四、本地Linux系统部署，搭建宝塔Linux面板，通过内网穿透实现域名访问</h2><blockquote>
<p>​		本节主要介绍假如没有云服务器，而手头刚好有一块linux的开发板（比如树莓派—也包括其他XX派，软路由，NAS等），可以实现再本地的linux电脑上假设网站，然后通过内网穿透服务（内网穿透有多种方法，比如如果自己有云服务器，可以通过自己搭建frp，或者nps实现内网穿透），当然，也有一些其他的内网穿透方法，这里不一一介绍了。但是，一般情况下内网穿透软件都是由两部分组成，服务端和客户端，服务端也需要部署在一个拥有公网IP的机器上（本身上还是需要一个云服务器），当然也可以用一个云服务器给多个内网设备做穿透，这个取决于个人的业务需求和选择。</p>
<p>​		如果你没有云服务器（而如果你只需要实现一个博客网站，也不需要专门购买一个云服务器，虽然一个云服务器本身并不贵，而且阿里云，腾讯云，华为云还经常由活动，一个基本的云服务器在做活动的时候是需要几十到百来元&#x2F;一年不等的价格），也可以采用其他服务商提供的内网穿透服务来实现访问，有免费的有收费的，这里只是提供一种思路，所以采用了第三方公司的内网穿透服务natapp，它是一家国内基于ngrok的内网穿透服务提供商。它有免费的和收费的可以选择，内网穿透的服务器也可以选择国内服务器和香港的服务器，如果你的域名已经备案，可以选择国内服务。如果域名没有备案，也可以选择香港的服务器。不过免费的内网穿透方案，不支持绑定自己的域名，只能使用服务商提供的二级域名。</p>
<p>​		可能涉及到的软件和工具：</p>
<ul>
<li><p>frp内网穿透工具：<a href="https://gofrp.org/zh-cn/">https://gofrp.org/zh-cn/</a></p>
</li>
<li><p>nps内网穿透工具：<a href="https://ehang-io.github.io/nps/#/">https://ehang-io.github.io/nps/#/</a></p>
</li>
<li><p>ngrok 反向代理： <a href="https://ngrok.com/">https://ngrok.com/</a></p>
</li>
<li><p>natapp内网穿透服务：<a href="https://natapp.cn/">https://natapp.cn/</a></p>
</li>
</ul>
<p>​		另外，由于本次实验采用的开发板也是基于ubuntu的系统，所以，再部署git服务器和安装和配置宝塔Linux面板操作（即1和2部分）和在云服务器上基本一样，只是ip地址变成了局域网的ip地址，你只需要按照上一章节的1和2部分一样操作即可。这里就不重复介绍了，这里假设你已经在开发板上部署好了你的博客系统。只是介绍如何部署内网穿透，以及如何在宝塔Linux面板中配置与内网穿透对接实现域名访问。</p>
</blockquote>
<h3 id="1、-把在本地部署的hexo博客通过内网穿透绑定自主域名"><a href="#1、-把在本地部署的hexo博客通过内网穿透绑定自主域名" class="headerlink" title="1、 把在本地部署的hexo博客通过内网穿透绑定自主域名"></a>1、 把在本地部署的hexo博客通过内网穿透绑定自主域名</h3><ol>
<li>进入natapp的网站注册一个账号，注意，natapp的默认免费通道是不支持绑定自主域名的，如果你的域名没有备案，则需要购买香港服务器（HK-1和HK-2型）。由于我们已经有一个测试的备案域名，所以我们购买一个1个月的VIP-1型，另外，如果需要绑定已经备案自主域名还需要花费1元购买10积分，添加一个备案域名（HK型可以直接添加自定义域名）。添加的备案域名可以在自主域名处查看到(这里我们以一个我已经备案的域名senyblog.com为例)：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405092309226.png" alt="natapp1"></p>
<ol start="2">
<li>接着我们可以配置我们的VIP-1 型通道，设置如下：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405092313428.png" alt="natapp2"></p>
<blockquote>
<p>​		 这里简单介绍以下，我们选择自主域名，并且以我们备案的域名<code>www.senyblog.com</code>作为自主域名，来映射到服务器的主机的80端口上，免费开启https是指在我们有SSL证书的情况下，可以开启安全的https访问。这个后面会说明。</p>
<p>​		注意到通道名称上面有一个<code>authtoken</code>字符串，这个后面我们在客户端中需要用到。</p>
</blockquote>
<ol start="3">
<li>我们需要在域名提供商（我们域名是在阿里云购买），设置域名解析，把<code>senyblog.com</code>域名的主机记录：www，以CHANE的记录类型，记录值为通道提供的 <code>c80de39d61648d86.natapp.cc</code> 上。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405092329539.png" alt="natapp3"></p>
<ol start="4">
<li>然后我们进入到宝塔linux面板，在网页中添加我们的备案域名<code>www.senyblog.com</code>，如下图：</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405092317581.png" alt="baota6"></p>
<ol start="5">
<li><p>我们从natapp官网下载客户端（根据自己的服务器类型，我们采用的是RK3588的处理器，64位的ubuntu系统，所以选择<code>Linux/ARM 64位</code>版本），然后用支持文件传输的ssh工具（这里使用<code>MobaXterm</code>,当然也可以直接使用宝塔的linxu面板来传输文件)，把文件传输到<code>/usr/local/natapp/</code>中（如果没有则创建对应的文件夹），也就是把下载的natapp的应用程序拷贝到该目录下。</p>
</li>
<li><p>以root权限，在终端中进入<code>/usr/local/natapp/</code>目录，给与<code>natapp</code>的运行权限，并运行<code>natapp</code>，其中的<code>-authtoken=XXXXXXX</code>填入通道的<code>authtoken</code>值即可。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo root</span><br><span class="line">cd /usr/local/natapp/</span><br><span class="line">chmod a+x natapp</span><br><span class="line">./natapp -authtoken=XXXXXXX</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>这个时候我们就可以通过能够上网的任何设备，直接用<code>www.senyblog.com</code>访问我们的网页了。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405092339721.png" alt="natapp4"></p>
<ol start="8">
<li>这时候只是可以访问，但是每次启动我们的开发板，需要重新运行一次<code>./natapp -authtoken=XXXXXXX</code>命令来启动<code>natapp</code>,且需要占用终端。这里给出两个方案，一个是后台运行，一个是开启自启动</li>
</ol>
<ul>
<li><p>后台运行 ： 直接<code>nohup ./natapp -authtoken=xxxx -log=stdout &amp;</code>来运行natapp即可，如果需要退出，可以通过<code>ps -ef|grep natapp</code>来查看<code>narapp</code>进程，然后通过<code>kill -9 id</code>来关闭<code>natapp</code>，详细可以参考：<a href="https://natapp.cn/article/nohup">https://natapp.cn/article/nohup</a></p>
</li>
<li><p>通过脚本设置开启自启动，按照如下操作</p>
<ol>
<li>从网站：<a href="https://natapp.cn/article/config_ini">https://natapp.cn/article/config_ini</a> 下载config.ini文件，填写<code>authtoken</code>的值，并把该文件上传到<code>natapp</code>的目录下，即<code>/usr/local/natapp/</code>目录下</li>
<li>可以通过直接运行<code>./natapp</code>测试运行natapp是否正常，如果正常，则下一步</li>
<li>下载开启自启动脚本：<a href="https://github.com/natapp/natapp_autostart%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%80%89%E6%8B%A9%60RaspberryPi%60%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%60natapp%60%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%A4%96%E8%AF%A5%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%AE%9A%E4%B9%89natapp%E7%9B%AE%E5%BD%95%E4%B8%BA%60/usr/natapp%60%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E4%B8%BA%60/usr/local/natapp/%60%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%A5%BD%E5%90%8E%E6%8A%8A%E8%AF%A5%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%60/etc/init.d/%60%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82">https://github.com/natapp/natapp_autostart，这里我们选择`RaspberryPi`目录下的`natapp`脚本文件，由于外该脚本中定义natapp目录为`/usr/natapp`，我们需要修改为`/usr/local/natapp/`，修改好后把该脚本文件拷贝到`/etc/init.d/`目录下。</a></li>
<li>给与该脚本文件755权限<code>sudo chmod 755 /etc/init.d/natapp</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 /etc/init.d/natapp</span><br></pre></td></tr></table></figure>



<ol>
<li>运行<code>sudo /etc/init.d/natapp start</code>测试脚本启动情况,如果允许正常，则可以加入开机自动启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/init.d</span><br><span class="line">sudo update-rc.d natapp defaults 90</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>输入<code>sudo reboot</code>尝试重启设备，然后验证服务是否启动正常，如果正常，则表示没有问题</li>
<li>可以通过如下命令关闭对脚本进行控制</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/natapp start    #开启</span><br><span class="line">sudo /etc/init.d/natapp stop     #关闭</span><br><span class="line">sudo /etc/init.d/natapp restart  #重启</span><br><span class="line"></span><br><span class="line">cd /etc/init.d</span><br><span class="line">sudo update-rc.d natapp defaults 90    #加入开机启动</span><br><span class="line">sudo update-rc.d -f natapp remove  #取消开机启动</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="9">
<li>到这里，在本地开发板上架设博客，并绑定自己域名实现远程访问的功能就实现了。如果采用这种方式，你只需要有一个可以允许linux的开发板，一个备案的域名，额外，natapp添加一个备案域名费用1元，外加可能需要一个月9元内网穿透的隧道费用。就可以实现部署一个自己域名的网站或者博客了。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>hexo博客系统</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Linux</tag>
        <tag>宝塔面板</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
</search>
