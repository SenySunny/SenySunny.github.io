<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><meta name="referrer" content="no-referrer"><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库 | SenySunny</title><meta name="author" content="SenySunny"><meta name="copyright" content="SenySunny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该项目的演示视频，详见： ​	GitHub仓库： https:&#x2F;&#x2F;github.com&#x2F;SenySunny&#x2F;modbus_rt.git  ​	Gitee仓库： https:&#x2F;&#x2F;gitee.com&#x2F;SenySunny&#x2F;modbus_rt.git ​	B站介绍视频和教程：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1cc411m72m&#x2F; 一、介绍​		modbus_rt是一款完全">
<meta property="og:type" content="article">
<meta property="og:title" content="modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库">
<meta property="og:url" content="http://senyblog.com/articles/modbus_0001.html">
<meta property="og:site_name" content="SenySunny">
<meta property="og:description" content="该项目的演示视频，详见： ​	GitHub仓库： https:&#x2F;&#x2F;github.com&#x2F;SenySunny&#x2F;modbus_rt.git  ​	Gitee仓库： https:&#x2F;&#x2F;gitee.com&#x2F;SenySunny&#x2F;modbus_rt.git ​	B站介绍视频和教程：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1cc411m72m&#x2F; 一、介绍​		modbus_rt是一款完全">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/SenySunny/picture/raw/master/img/modbus.png">
<meta property="article:published_time" content="2023-06-22T15:13:21.000Z">
<meta property="article:modified_time" content="2024-05-13T12:37:08.370Z">
<meta property="article:author" content="SenySunny">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="自动化">
<meta property="article:tag" content="通信协议">
<meta property="article:tag" content="modbus">
<meta property="article:tag" content="物联网">
<meta property="article:tag" content="PLC">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="ESP32">
<meta property="article:tag" content="CAT1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/SenySunny/picture/raw/master/img/modbus.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://senyblog.com/articles/modbus_0001.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-13 20:37:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/SenySunny/picture/raw/master/img/Avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/SenySunny/picture/raw/master/img/modbus.png')"><nav id="nav"><span id="blog-info"><a href="/" title="SenySunny"><span class="site-name">SenySunny</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-22T15:13:21.000Z" title="发表于 2023-06-22 23:13:21">2023-06-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/modbus%E5%8D%8F%E8%AE%AE/">modbus协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="modbus_rt：本人编写的纯C实现的跨平台modbus协议通信库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>该项目的演示视频，详见：</p>
<p>​	GitHub仓库： <a target="_blank" rel="noopener" href="https://github.com/SenySunny/modbus_rt.git">https://github.com/SenySunny/modbus_rt.git</a> </p>
<p>​	Gitee仓库： <a target="_blank" rel="noopener" href="https://gitee.com/SenySunny/modbus_rt.git">https://gitee.com/SenySunny/modbus_rt.git</a></p>
<p>​	B站介绍视频和教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cc411m72m/">https://www.bilibili.com/video/BV1cc411m72m/</a></p>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>​		modbus_rt是一款完全基于C语言实现的可以运行在windows, linux,  macos， RTOS上的modbus通信库。主要目的是针对控制系统和工业物联网的方向使用。modbus_rt可以同时支持slave模式和master模式，基于类似socket句柄的实现思想，可以很方便的支持多例模式。它不仅仅是modbus协议的解析和实现，而是尽可能的在应用层做好实现和封装，做到开箱即用，而不需要做过多的应用层移植。</p>
<p>​		modbus_rt支持几乎市面上常用的所有的modbus协议的实现，包括<strong>modbus RTU</strong>，<strong>modbus ASCII</strong>，<strong>modbus TCP</strong>，<strong>modbus TCP over UDP</strong>，<strong>modbus RTU over TCP&#x2F;UDP</strong>, <strong>modbus ASCII over TCP&#x2F;UDP</strong>，且都可以运行在<strong>Slave模式</strong>和<strong>Master模式</strong>。另外modbus_rt提供了modbus通信中的大小端转换函数接口(市面上<strong>4种大小端模式</strong>均支持)，实现不同平台下的modbus寄存到各种数据的转换接口函数功能（包括bytes, string, int, long, float, double等）。</p>
<p>​		modbus_rt还额外提供了基于pikapython的接口实现，并整合进pikapython的官方的包管理器。可以采用python脚本实现modbus通信功能。可以无缝兼容到pikapython的环境当中（后续可能考虑提供基于micro python和Cpython的接口实现，本人对micro python和Cpython的底层封装不是很熟悉，看情况，不一定有时间，感兴趣的可以自己移植）。</p>
<p>​		另外由于modbus_rt采用纯C编写，后续会考虑支持编译封装为动态链接库，供其他编程语言调用（主要考虑给C#调用，目前主要的控制上位机平台基于QT或者C#居多），目前暂时没有封装dll，所以仅提供基于QT的demo。</p>
<h4 id="1、-modbus-rt的主要特性如下："><a href="#1、-modbus-rt的主要特性如下：" class="headerlink" title="1、 modbus_rt的主要特性如下："></a>1、 modbus_rt的主要特性如下：</h4><ol>
<li>可以无缝运行在市面上绝大部分平台，包括：windows，Linux，嵌入式RTOS系统当中（计划会维护rt-thread和FreeRTOS系统）。</li>
<li>采用线程实现应用层接口，可以快速实现多个modbus 实例应用。支持几乎所有的modbus协议，且均支持Slave模式和Master模式。</li>
<li>同时支持市面上4种不同模式的大小端数据转化接口，实现不同平台下的modbus寄存到各种数据的转换接口函数功能（包括bytes, string, int, long, float, double等）。</li>
<li>基于面向对象的思维方式，采用句柄模式，非常方便实现modbus的多例模式。理论上只要性能，内存和空间足够，可以创建无数个modbus实例。</li>
<li><strong>modbus master在tcp模式下支持断线重连功能（包括tcp master和rtu&#x2F;ascii master over tcp）</strong>。在modbus的网络通信中，由于slave是服务端，master为客户端，可能由于网络或者服务端的原因（有些服务端为了保证性能是会自动做短链接处理。就是每进行一次modbus通信之后，会主动断开与客户端的连接，以减小性能开销）。这种情况下，会出现master每次通信需要判断服务端有没有断开，如果断开则需要重新建立连接。modbus_rt内部支持断线重连机制，即使由于网络或者服务端原因断开了连接，下次通信不需要重新建立连接。直接调用功能函数即可，应用框架会自动进行重连（内部有功能调用时重连和定时重连两方面处理，定时重连可以通过宏定义打开或者关闭——针对具有自动断开机制的服务端系统，可以考虑关闭定时重连，否则服务端断开之后系统会间隔的尝试与服务器进行重连。针对其他应用，开启定时重连的目的时为了防止由于网络或者超时原因导致的断开，系统会自动进行重连）。</li>
<li><strong>基于UDP通信接口之上modbus模式下，提供了网络设备查找和发现功能</strong>。即：modbus slave端（一般可以称为设备端，以下简称设备端）与modbus master端（一般PC客户端或者应用端，以下简称客户端）为同一个路由器或者交换机下面的不同设备时。即使设备端与客户端的IP地址不在同一个网段下（设备端IP地址未知），可以由客户端通过往255.255.255.255的广播地址广播modbus命令，设备端收到广播信息后会对广播设备的ip地址进行检测，如果与设备不在同一个网段，会默认往255.255.255.255广播应答信息。这个时候，客户端就可以获取到modbus_rt设备端的ip地址。这样就可以实现设备地址的发现。另外基于此基础上可以扩展实现修改设备的IP地址的功能（详细可以参考rt-thread平台演示）。</li>
<li><strong>mdobus_rt在slave模式下，增加了set_pre_ans_callback和set_done_callback两个回调函数调用接口</strong>。方便快速实现modbus协议与其他协议的转换。比如modbus RTU，ASCII，TCP之间的相互转化， modbus转mqtt，modbus转sql， modbus转OPC Client， modbus转profibus，modbus转canOpen等协议（第三方协议需要自己实现）。可以快速实现类似DTU的应用，以适应各种工业物联网的应用需求（详细可以参考modbus dtu案例演示）。</li>
<li><strong>modbus_rt提供脚本的应用层接口API，目前实现基于pikapython</strong>（主要是考虑到pikapython本身采用python3语法，且支持windows，linux，RTOS，甚至无系统的跨平台支持），并且支持脚本解析运行模式和字节码运行模式，且提供了REPL的交互式运行模块。所以可以无缝集成到系统当中，也可以采用类似终端的方式，基于REPL的命令行模式来验证功能。</li>
<li><strong>（2024-01-31增加）支持自动modbus功能码实现文件下载和上传功能</strong>：可以方便的用modbus_rt实现固件升级和其他文件（比如pikapython的字节码）下载上传功能。并且可以选择使用mbedTLS对固件和文件进行加密，实现加密的文件下载和上传。</li>
</ol>
<h4 id="2、-modbus-rt的几点补充说明："><a href="#2、-modbus-rt的几点补充说明：" class="headerlink" title="2、 modbus_rt的几点补充说明："></a>2、 modbus_rt的几点补充说明：</h4><ol>
<li>modbus_rt的协议解析部分基于开源的agile_modbus协议栈修改而来。针对slave_util部分做了重写，主要是支持动态绑定slave寄存器，甚至可以运行中增加slave寄存器。</li>
<li>在基于windows，linux（理论上也可以运行在macos系统）上的串口通信部分采用了开源的libserialport串口通信库，采用加载动态链接库的形式调用，RTOS部分串口通信代码为自己编写。</li>
<li>modbus_rt的网络通信部分，采用BSD Socket接口，所以理论上只要可以支持BSD Socket的平台都可以使用，需要注意的是：为了实现多个socket的阻塞问题，采用了IO多路复用接口（select机制），所以需要系统支持select接口。windows和linux本身就都支持，RTOS系统需要确保系统已经移植了BSD socket并且支持select。</li>
<li>modbus_rt的应用实现层采用多线程，在windows，linux，macos等操作系统上采用了pthread多线程。linux和macos默认支持pthread，windows需要自己加载和安装pthread库。</li>
<li>本项目参考和借鉴使用了包括但不仅限于以下开源的项目：agile_modbus,  libserialport, PikaPython, PikaPython-OpenHardware, RT-Thread, FreeRTOS等等(如还有没有标注的项目，请注明)。采用和借鉴了的开源项目地址详见最后感谢栏，欢迎大家点赞相互交流学习。感谢以上的开源项目作者。</li>
</ol>
<h3 id="二、重大的更新记录"><a href="#二、重大的更新记录" class="headerlink" title="二、重大的更新记录"></a>二、重大的更新记录</h3><h4 id="1、2024-03-01更新内容"><a href="#1、2024-03-01更新内容" class="headerlink" title="1、2024-03-01更新内容"></a>1、2024-03-01更新内容</h4><ol>
<li>修复了modbus_rt在slave模式下，如果绑定寄存器乱序绑定modbus slave寄存器的时候会导致链表数据丢失。（之前测试都是按照从小到大，或者从大到小，没有测试全面，如果地址顺序是乱的，则会出错，最新版本已经修复）——感谢网友“皓月”发现bug。</li>
<li>增加了modbus_rt在freeRTOS系统的支持，并提供了在ESP32和air780e硬件平台的demo示例。</li>
<li>增加了cmsis_rtos2的RTOS兼容层的platform接口移植（并提供了基于freertos的cmsis_rtos2的兼容层）。该接口由网友“皓月”提供并移植验证。本人暂时没有验证，针对非rt-thread或则freeRTOS的用户，可以尝试使用cmsis_rtos2的兼容层使用。本人后续抽空验证之后，会提供验证的demo示例。</li>
</ol>
<h4 id="2、2024-01-31更新内容"><a href="#2、2024-01-31更新内容" class="headerlink" title="2、2024-01-31更新内容"></a>2、2024-01-31更新内容</h4><ol>
<li><p>把SLAVE_DATA_DEVICE_BINDING宏定义，修改为SLAVE_DATA_DEVICE_BINDING宏定义和dev_binding标志变量共同决定是否需要把SLAVE的硬件外设绑定到寄存器当中。所以在设备需要绑定硬件外设时，需要额外调用 modbus_xxx_set_dev_binding(xxx_modbus_device_t dev, int flag)函数来实现绑定变量，否则默认为不绑定，可以作为完全独立的modbus实例存在。这样做的目的是为了在交互端，PC上基于DTU的代码可以几乎不用移植的在嵌入式设备上运行。</p>
</li>
<li><p>增加基于modbus的添加文件传输功能（类似tftp，采用mosbus自定义功能码实现，功能码可以在mosbus_p2p.h中自行修改），可以用该功能实现固件升级(可选择加载加密代码实现固件的加密传输和升级)。另外可以实现串口，网络直接传输pikapython的字节码到设备端（如果设备端有文件系统支持），设备端直接运行字节码，使得在设备端运行pikapython更加高效和便捷。（该功能可以通过宏定义打开或者关闭，关闭文件传输功能，与之前版本兼容）。</p>
</li>
<li><p>整合到pikaPython的官方仓库，可以直接使用pikaPython的包管理工具加载和更新。并且对大小端转化、RTU和TCP做了分割，方便只需要使用Modbus TCP或者只需要使用modbus RTU的用户，也可以快速modbus_rt到项目中（需要RTOS或者操作系统支持，暂时不支持裸机运行modbus_rt）。</p>
</li>
<li><p>把modbus中的协议解析部分，与agile modbus同步更新到1.1.4版本的agile modbus</p>
</li>
<li><p>example中的案例暂时还未同步更新，后续抽空会同步更新到最新版本。</p>
<blockquote>
<p><strong>需要特别注意的是：</strong> 考虑到第1条可能会导致部分使用之前版本代码的用户（仅限在设备端，绑定了硬件本身的IO外设的情况下）在升级到最新版本之后，可能会有一定的兼容性问题（需要在创建modbus slave实例之后，除开需要把宏定义SLAVE_DATA_DEVICE_BINDING设置为1打开，还需要增加额外增加一条modbus_xxx_set_dev_binding函数，才可以实现完全的与硬件绑定功能）。如果不需要以上功能的用户可以直接使用发布的betaV0.1版本。（推荐还是使用最新版本，毕竟有些小Bug最新版本做了更新和修复，所以betaV0.1版本，仅限已经使用了该通信库，且没有额外需求，防止更新导致不兼容的小伙伴。）</p>
</blockquote>
</li>
</ol>
<h3 id="三、测试与使用"><a href="#三、测试与使用" class="headerlink" title="三、测试与使用"></a>三、测试与使用</h3><h4 id="1、-windows平台"><a href="#1、-windows平台" class="headerlink" title="1、 windows平台"></a>1、 windows平台</h4><p>​		windows平台我们这里我们采用QT+MSVC来编译进行测试（理论上用Visual Studio—本身就是基于MSVC，或者MiniGW—基于GCC都可以），我们提供了两个demo：modbus_rt_slave_test和pikapython_test。</p>
<ol>
<li>modbus_rt_slave_test测试程序会运行三个modbus示例，分别为modbus rtu slave， modbus tcp slave和modbus tcp slave over udp。我们可以通过任意一种modbus与其进行通信，这里我们直接用第二个案例pikapython_test来测试（当然也可以用其他软件或者设备进行通信，比如：modbus poll软件）。直接用QT打开工程修改电脑上的串口号和电脑所用网卡的ip地址，编译即可。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753109.png" alt="slave_demo_qt"></p>
<ol start="2">
<li>一、介绍</li>
</ol>
<p>这里我们简单测试用pikapython_test程序，运行<code>rtu_master.py</code>、<code>tcp_master.py</code>、<code>udp_master.py</code>来进行基本功能测试，详细测试方法可以参考演示视频（这里就不赘述了）：</p>
<p>​		我们也可以基于pikapython_test左更多的功能，可以参考后面的案例。</p>
<p>​		如果需要编译到自己的应用程序中，只需要把src目录的代码复制到工程当中去，安装pthread库和libserialport库，自己添加好头文件即可，可以参考我们提供的两个QT+MSVC的源码工程。</p>
<h4 id="2、Linux平台"><a href="#2、Linux平台" class="headerlink" title="2、Linux平台"></a>2、Linux平台</h4><p>​		Linux平台硬件理论上只要时标准的linux系统都可以使用。这里我采用了野火的鲁班猫1作为测试平台，基于瑞芯微（Rockchip）的RK3566平台。主要是手头刚好又这个开发板，而且而且目前市面上很多ROS机器人系统都采用了这块开发板，具有一定的代表性，modbus_rt时上层的应用开发API，所以实际上与硬件无关。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753709.png" alt="lubancat1"></p>
<p>​		linux系统我们提供了和Windows功能一样的两个demo。我们直接编译即可运行。由于linux环境搭建可能针对初学者有些难度，这里简单简述以下编译环境的构建和编译过程。详细的测试方法可以参考演示视频，视频中我们提供了一个案例，就是用两个USB转485的线分别连接windows和linux。然后进行相互通信测试。</p>
<p>​		这里我们刷了野火提供的最新的debian桌面版本的固件。确保安装了git, cmake和gcc程序，如果没有安装可以通过<code>sudo apt install cmake</code> 和<code>sudo apt install git</code>来安装（由于我的开发板系统安装在EMMC中，而flash空间不够，所以代码是在tf卡中编译的，我把tf卡挂载到了<code>/home/cat/sdcard</code>目录下，需要注意给<code>/home/cat/sdcard</code>目录操作权限）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/mmcblk1 /home/cat/sdcard</span><br><span class="line">sudo chown -R cat /home/cat/sdcard</span><br><span class="line">chmod -R 755 /home/cat/sdcard</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果要在linux下编译libserialport，还需要安装autotools相关工具，因为libserialport是在linux下是基于autotools工具编译的，如果需要编译libserialport下面的example示例，可能还需要安装pkg-config工具。请更具提示安装对应的编译工具</p>
</blockquote>
<ol>
<li>下载libserialport和modbus_rt的源代码，libserialport的地址详见最后的参考的项目地址中。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sigrokproject/libserialport.git</span><br><span class="line">git clone https://github.com/SenySunny/modbus_rt.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装autotools工具和pkg-config工具</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autotools-dev autoconf automake libtool</span><br><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译和安装libserialport库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd libserialport/</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure </span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果需要运行libserialport下的案例，可以进入examples目录下，执行make编译。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd examples/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>   ​	 此时你可以运行案例，比如以下是运行<code>./list_ports</code>的结果，显示由两个串口，一个是系统调试串口，一个是我外界的USB转串口模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat@lubancat:~/sdcard/libserialport/examples$ ./list_ports </span><br><span class="line">Getting port list.</span><br><span class="line">Found port: /dev/ttyFIQ0</span><br><span class="line">Found port: /dev/ttyUSB0</span><br><span class="line">Found 2 ports.</span><br><span class="line">Freeing port list.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编译和运行modbus_rt(注意编译前线修改代码中的ip地址和串口号等信息)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/modbus_rt_slave_test</span><br><span class="line">sh make.sh</span><br><span class="line">sudo build/modbus_rt_linux </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果要运行pikapython_test案例，编译方法一样，</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/pikapython_test</span><br><span class="line">sh make.sh</span><br><span class="line">sudo build/modbus_rt_linux </span><br></pre></td></tr></table></figure>

<p>​			或者进入目录运行特定的文件，例如下面即直接运行目录下的test.py文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">sudo ./pikapython test.py </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>可以运行和测试modbus_rt相关功能</li>
</ol>
<p>​		测试方法和windows一样，需要注意的是，linux终端和windows略有不同，windows的终端可以直接输入程序名称运行程序，而linux终端输入程序名称会检测环境变量下的有没有该名称的程序，并不会直接运行目录下的程序，所以需要输入<code>.\pikapython</code> 或者运行<code>.\pikapython xxx.py</code>运行程序，另外，如果程序中socket用到了1024以下的端口号，比如modbus默认的502，需要用管理员模式运行，需要输入<code>sudo .\pikapython</code>或者<code>sudo .\pikapython xxx.py</code>运行程序。因为linux系统默认用户不能使用1024以下的端口号。</p>
<blockquote>
<p>还有一点需要注意：如果用windows系统或者linux系统作为设备端使用。开启基于udp的slave模式。希望开启设备IP查找功能，windows系统创建slave设备的时候，需要指定网卡的ip地址，类似windows测试时的“192.168.28.150”。linux系统或者RTOS系统下BSD socket则需要用NULL或者空子字符串“”来指定采用默认IP地址。否则接收不到来自255.255.255.255的广播数据包。</p>
</blockquote>
<h4 id="3、RT-Thread平台"><a href="#3、RT-Thread平台" class="headerlink" title="3、RT-Thread平台"></a>3、RT-Thread平台</h4><p>​		RT-thread平台演示提供了两套硬件，其中一套硬件是自己DIY的一块PLC开发板，考虑到使用者并没有这个板子做验证，另外这个板子的网络部分采用了W5500的网络芯片来实现的，增加了STM32+lan8720A+lwip的案例演示，该开发板基于”野火STM32F407_骄阳开发板“来实现，关于该开发板的资料可以参考”野火资料下载中心：<a target="_blank" rel="noopener" href="https://doc.embedfire.com/products/link/zh/latest/mcu/stm32_motor/ebf_stm32f407_jiaoyang/download/stm32f407_jiaoyang.html">https://doc.embedfire.com/products/link/zh/latest/mcu/stm32_motor/ebf_stm32f407_jiaoyang/download/stm32f407_jiaoyang.html</a> “</p>
<h5 id="（1）-基于APM32E103VET6-W5500"><a href="#（1）-基于APM32E103VET6-W5500" class="headerlink" title="（1） 基于APM32E103VET6 + W5500"></a>（1） 基于APM32E103VET6 + W5500</h5><p>​		RT-thread平台演示采用了我之前自己DIY的一块PLC开发板，外壳完全兼容西门子的S7-200的PLC外壳，主控这里采用国产的珠海半导体的APM32E103VET6芯片（基本兼容STM32F103VET6，引脚Pin2Pin兼容，但是RAM时STM32的2倍，128K，STM32只有64K，另外APM32的主频为120Mhz），网络部分采用W5500网络芯片。运行rt-thread系统。电路图和测试代码可以见<code>example\rt-thread\apm32e103vet6</code></p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131753732.png" alt="rt-thread_PLC"></p>
<p>​	</p>
<p>​		该硬件有两个RS485接口，我们代码默认靠近网卡的RS485作为终端测试使用，我们连上网线，RS485线缆(一个用于modbus通信，一个用于终端调试)，上电，编译下载到硬件平台之后。我们可以通过modbus poll控制和读取IO的状态，也可以使用前面编译好的windows或者linux应用程序在终端运行modbus master示例，与其通信。</p>
<blockquote>
<p>​		这里对代码做简要的说明，我们创建了三个slave示例，一个用于modbus rtu slave on RS485，一个modbus tcp slave，一个基于modbus tcp slave over udp。其中udp的slave支持设备查找功能。</p>
<p>寄存器分布如下：</p>
<p>0x寄存器：	20000~				: DO输出寄存器</p>
<p>1x寄存器：	10000~				：DI输入寄存器（只读）</p>
<p>3x寄存器：	8000-8007			: 存储设备的基本信息</p>
<p>​						8008-8015	  	：设备的硬件地址(这里便是MAC地址），注意8008存储的式地址长度</p>
<p>​														（这里是6），8009-8011存储的是MAC地址，8012~8015这里没有使用。</p>
<p>​						8016-8025		:	这里存储的是设备的网络信息分别是IP地址，子网掩码，网关地址，</p>
<p>​														首选DNS服务器，备用DNS服务器。每个占用2个地址。</p>
<p>4x寄存器：	2008-2015	    ： 引入MAC地址匹配功能，针对广播修改网络信息功能。定义与8008-8015相同。</p>
<p>​						2016-2027		： 修改网络信息地址寄存器，2016-2025地址分别是IP地址，子网掩码，</p>
<p>​														网关地址，首选DNS服务器，备用DNS服务器，每个占用2个地址。</p>
<p>​														2016为修改确认标识，表示修改哪些信息，可以取值为0~5。</p>
<p>​														默认0不修改，</p>
<p>​																1	表示只传递ip，子网掩码和网关采用默认（子网掩码默认</p>
<p>​																		255.255.255.0，网关地址默认为ip同一网段下的xxx.xxx.xxx.1）;</p>
<p>​																2	表示只传递ip和子网掩码,网关采用默认；</p>
<p>​																3	表示ip，子网掩码和网关同时修改)</p>
<p>​																4	增加修改首先DNS服务器</p>
<p>​																5	所有的信息都修改。</p>
<p>​													2017为开启DHCP模式，设置1则表示开启，仅对当前有效，设置后DHCP获取</p>
<p>​													到的IP地址等网络信息会存储在3x寄存器的8016-8025当中，重启之后，系统</p>
<p>​													会回到静态ip模式，并把上次DHCP的IP作为静态IP来设置，所以该模式作用于</p>
<p>​													在不知道路由器可用IP的情况下让路由自动给设备分配一个ip使用。</p>
</blockquote>
<p>​		该代码和windows和linux的modbus_rt_slave_test功能一致，即运行三个modbus slave实例，分别基于RS485，tcp和udp。其中udp我们增加了网络搜索设备和修改设备网络信息的功能。同时我们基于QT编写了一个查找和修改设备网络信息的上位机程序（本身也是基于modbus_rt），在<code>example\windows\tools\find_device</code>目录下，我们编译程序下载到单片机之后，就可以用这个软件查找和修改设备的IP了（该软件查找设备支持多设备同时查找，但是修改跨网段的设备的网络信息是默认不支持多设备，这里主要的原因是：查找设备是通过广播查找，但是如果发现设备与电脑不在同一个网段，则会通过广播修改网络信息，但是如果发现设备本身和电脑在同一个网段，则会使用定向ip地址发送信息）。</p>
<blockquote>
<p>针对RT-Thread平台代码做了修改，增加了MAC地址匹配功能，这样便支持跨网段的多设备修改功能了（需要注意的是：MAC地址匹配功能不属于modbus_rt应用框架内的功能。需要自己应用端去实现和匹配，且一定要确保MAC具有唯一性，如果多设备的MAC一样，该功能可能会导致问题。最新版本的固件代码已经增加MAC地址匹配功能。）。</p>
</blockquote>
<p>​		目前查找和修改设备IP上位机目前只提供window平台，linux平台暂时未提供，使用方法将建演示视频。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131754984.png" alt="device_find"></p>
<p>软件的简介和使用说明，详见仓库中的[软件说明手册]</p>
<h5 id="（2）-基于STM32F407-lan8720A-lwip"><a href="#（2）-基于STM32F407-lan8720A-lwip" class="headerlink" title="（2） 基于STM32F407 + lan8720A + lwip"></a>（2） 基于STM32F407 + lan8720A + lwip</h5><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131754548.png" alt="stm32f407_jiaoyang"></h6><p>​        这里我们基于野火STM32F407_骄阳开发做了两个demo，demo的功能和windows基于Linux平台的功能一样，这里需要注意的是：</p>
<ol>
<li>第一个demo和基于APM32E103VET6的demo一样，增加了网络设备查找的功能，可以通过”查找和修改设备IP上位机“进行设备发现和修改设备的网络信息。</li>
<li>第二个demo由于是在嵌入式平台运行python代码。考虑的文件的传输，这里利用开发板上的SPI Flash 建立了一个FAT文件系统，把其绑定在USB_DEVICE_MSTORAGE设备上，这样就可以把开发板作为一个U盘来使用了。需要拷贝python文件的时候，直接接入USB设备，文件系统就会挂在到USB_DEVICE_MSTORAGE设备上，这时候可以拷贝和编辑里面的PikaPython的python代码。编辑保存完毕之后断开USB，此时文件系统会直接挂在在FATFS文件系统下面，此时便可以通过MSH的命令行执行相应的python代码。（当然，还有很多其他方式可以实现，比如通过TFTP等协议传输文件，这里只是提供了一个demo示例）</li>
<li>另外，在code_py中增加了一个用STM32实现modbus TCP转RTU的DTU的案例，由于我们在STM32上已经做了寄存器绑定，所以这个demo和在PC上略微有一点不同，代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> modbus_rt</span><br><span class="line"><span class="keyword">import</span> modbus_rt_defines <span class="keyword">as</span> cst</span><br><span class="line"></span><br><span class="line">serial_name = <span class="string">&quot;uart4&quot;</span></span><br><span class="line">ip_addr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">rm = modbus_rt.rtu(cst.MASTER)</span><br><span class="line">rm.set_serial(serial_name)</span><br><span class="line">rm.<span class="built_in">open</span>()</span><br><span class="line">ts = modbus_rt.tcp()</span><br><span class="line">ts.set_net(ip_addr, <span class="number">502</span>, cst.SOCK_STREAM)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.READ_DISCRETE_INPUTS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = rm.excuse(slave, function, addr + <span class="number">10000</span>, quantity)</span><br><span class="line">            ts.excuse(cst.WRITE, cst.INPUTS, addr, quantity, data)</span><br><span class="line">    <span class="keyword">elif</span> cst.READ_COILS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = rm.excuse(slave, function, addr + <span class="number">20000</span>, quantity)</span><br><span class="line">            ts.excuse(cst.WRITE, cst.CIOLS, addr, quantity, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.WRITE_SINGLE_COIL == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = ts.excuse(cst.READ, cst.CIOLS, addr, <span class="number">1</span>)  </span><br><span class="line">            rm.excuse(slave, function, addr + <span class="number">20000</span>, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_COILS == function: </span><br><span class="line">        <span class="keyword">if</span> addr &gt;= <span class="number">0</span> <span class="keyword">and</span> addr &lt;= <span class="number">16</span> :</span><br><span class="line">            data = ts.excuse(cst.READ, cst.CIOLS, addr, quantity)  </span><br><span class="line">            rm.excuse(slave, function, addr + <span class="number">20000</span>, quantity, data)  </span><br><span class="line">ts.set_strict(<span class="number">0</span>)</span><br><span class="line">ts.set_pre_ans_callback(pre_call)</span><br><span class="line">ts.set_done_callback(done_call)</span><br><span class="line">ts.<span class="built_in">open</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        该代码执行的效果是，如果写20000线圈寄存器，则默认是写DO输出操作，如果写的是地址0的线圈寄存器，则会默认为通过RTU写扩展IO模块的20000线圈寄存器；同样的，如果是读10000离散输入寄存器，则默认读取的是开发板的DI输入，但是如果读取的是0的离散输入寄存器，则会默认通过RTU读取扩展模块的10000寄存器。这样就方便的对IO外设进行扩展，或者以支持以太网的设备作为主控，以RTU外设作为从机。实现主机对从机的调度。另外通过主机设备像上位机或者云端上传信息的功能。</p>
<h4 id="4、FreeRTOS平台"><a href="#4、FreeRTOS平台" class="headerlink" title="4、FreeRTOS平台"></a>4、FreeRTOS平台</h4><p>​	    FreeRTOS平台，我们针对两款硬件平台做测试，一款是PikaPython的开源硬件 PikaPython-OpenHardware，该硬件基于ESP32-S3平台，我们基于ESP-IDF V5.1版本开发，理论上可以兼容所有采用ESP-IDF的ESP32的设备，该开发板完全开源，板载隔离RS485接口，另外网络部分可以用wifi进行测试，实际上我们可以采用任何一款ESP32系列的开发板和最小系统板运行该实例。开发板的开源仓库为：<a target="_blank" rel="noopener" href="https://gitee.com/Lyon1998/pikapython_openhardware">https://gitee.com/Lyon1998/pikapython_openhardware </a>，开发板示意图如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755011.png" alt="PikaPython-OpenHardware"></p>
<p>​	    另外一款平台，我们基于合宙的air780E的4G Cat.1模组，其核心控制器采用移芯的EC618芯片平台，理论上也可以兼容air780EG，air780EP，air780EPV等采用移芯EC618，EC718的模组使用。</p>
<p>​	    我们采用的开发板为开源的pikapython-air780e开发板，其软硬件完全开源，开源仓库为：<a target="_blank" rel="noopener" href="https://gitee.com/Lyon1998/pikapython-air780e">https://gitee.com/Lyon1998/pikapython-air780e</a>, 该开发硬件上有隔离RS232，隔离RS485接口，还有其他丰富的扩展模块。开发板的示意图如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755760.jpg" alt="air780e"></p>
<h5 id="（1）-基于ESP32，采用ESP-IDF环境"><a href="#（1）-基于ESP32，采用ESP-IDF环境" class="headerlink" title="（1） 基于ESP32，采用ESP-IDF环境"></a>（1） 基于ESP32，采用ESP-IDF环境</h5><p>​        平台的测试代码仓库（基于idf V5.1开发环境），我们提供了两个demo，一个是运行modbus_rt的demo，一个是运行pikaPython的demo，工程代码在example\FreeRTOS\PikaPython_OpenHardware目录下：</p>
<ol>
<li>首先安装idf开发环境，以及vscode 的idf插件，可以参考如下文档：<a target="_blank" rel="noopener" href="https://pikapython.com/doc/board_wireless.html">https://pikapython.com/doc/board_wireless.html </a>, 也可以参考B站的idf开发视频，这里推荐一个视频：<a target="_blank" rel="noopener" href="https://space.bilibili.com/1375767826/channel/collectiondetail?sid=846684">https://space.bilibili.com/1375767826/channel/collectiondetail?sid=846684</a></li>
<li>用vscode打开对应的工程文件编译下载即可，这里特别需要注意的是，第一个modbus_rt案例，采用直接写死wifi的ssid和password的形式，如果要修改ssid和password，在vscode中按ctrl+p，在弹出的菜单中输入”&gt;ESP-IDF:SDK Configuration editor (menuconfig)”进入menuconfig界面。选择左侧的Example Connection Configuration选项卡，修改wifi路由器的SSID和密码等参数信息。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755205.png" alt="esp32_wifi"></p>
<ol start="3">
<li>另外，如果你采用的是ESP32-S3芯片，默认的终端调试串口采用USB-UART接口，希望采用uart0来运行modbus_rt的话，可以在menuconfig的配置项目中的Channel for console output选项，选择为USB Serial&#x2F;JTAG Controller，来关闭uart0的默认终端输出功能（如果不关闭，会导致uart0作为console端口与modbus通信冲突）。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755099.png" alt="esp32_console"></p>
<ol start="4">
<li>如果要运行PIKA_PI_WIRELESS_FIRMWARE固件，希望用wifi来运行modbus TCP或者其他基于网络的modbus实例的话，需要确保WiFi已经连接到AP路由上之后再用open函数运行modbus实例，否则，会导致由于网络未连接导致网络的modbus执行失败。</li>
</ol>
<h5 id="（2）-基于air780e，基于C语言，封装pikapython，采用xmake编译"><a href="#（2）-基于air780e，基于C语言，封装pikapython，采用xmake编译" class="headerlink" title="（2） 基于air780e，基于C语言，封装pikapython，采用xmake编译"></a>（2） 基于air780e，基于C语言，封装pikapython，采用xmake编译</h5><p>​        基于air780e的案例，可以直接采用pikapython-air780e官方仓库的代码，目前modbus_rt的实例已经与官方仓库同步。仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/Lyon1998/pikapython-air780e">https://gitee.com/Lyon1998/pikapython-air780e </a>，请按照官方仓库的说明编译和使用。</p>
<p>​        目前的air780e平台，考虑到4G Cat.1模组无局域网环境，暂时只适配modbus RTU和modbus ASCII，并没有适配modbus TCP等网络相关的modbus协议。</p>
<h4 id="5、mosbus-rt与西门子PLC进行通信"><a href="#5、mosbus-rt与西门子PLC进行通信" class="headerlink" title="5、mosbus_rt与西门子PLC进行通信"></a>5、mosbus_rt与西门子PLC进行通信</h4><p>​		因为我们以上4个平台的接口部分都是采用PikaPython封装的API，采用脚本进行通信，所以测试用哪个平台无所谓，西门子PLC我们采用比较常用的S7-1214C的PLC平台，这里仅仅测试modbus TCP，我们提供两个demo：</p>
<ol>
<li>S7-1214C运行modbus TCP master案例，连接到我们rt-thread平台硬件上，把rt-thread开发板作为西门子PLC的扩展modbus IO模块使用。这里我们简单做了一个应用，采样S7-1214C的I0.0作为启动连接到IO的信号，之后把rt-thread开发板的DI输出到DO中，此时我们输入板子的DI，对应的DO就有输出。详细可以参考演示视频。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131755684.png" alt="TIA1"></p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758904.png" alt="TIA1"></p>
<ol start="2">
<li>S7-1214C运行modbus TCP slave案例，利用windows或者linux上运行的mobus_rt 运行的master操作西门子PLC的外设（包括I Q IW和自定义的保持寄存器，I对饮的1x寄存器，Q对应的0x寄存器，IW对应的3x寄存器），详细可以参考演示视频。</li>
</ol>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758492.png" alt="TIA3"></p>
<p>​	PLC工程详见example&#x2F;PLC目录，工程采用博图V15.1创建工程。</p>
<h4 id="6、modbus-rt与组态屏进行通信"><a href="#6、modbus-rt与组态屏进行通信" class="headerlink" title="6、modbus_rt与组态屏进行通信"></a>6、modbus_rt与组态屏进行通信</h4><p>​		威纶通组态屏程序，我们用威纶通的MT8071IP组态屏，结合我们的RT-Thread平台硬件，进行DO控制和DI检测示例。威纶通屏幕的工程详解example&#x2F;WEINVIEW，采用EBproV6.08.02.500打开下载。理论上其他的组态屏操作也基本一致，这里就不一一测试了。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758167.png" alt="MT8071IP"></p>
<p>​		这里我们只是写了一个用威纶通屏幕读取DI并写入DO控制开发板的简易Demo, 监控四路输入和4路输出。组态屏屏本身可以通过modbus实现的功能非常强大，这里就不赘叙了。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758884.png" alt="WEINVIEW"></p>
<h4 id="7、modbus-rt与国产大彩串口屏进行通信"><a href="#7、modbus-rt与国产大彩串口屏进行通信" class="headerlink" title="7、modbus_rt与国产大彩串口屏进行通信"></a>7、modbus_rt与国产大彩串口屏进行通信</h4><p>​		考虑到很多成本敏感的项目或者用户并不会使用组态屏（主要价格贵）。所以这里我们也采用国产的大彩串口屏做了一个demo示例，国产的串口屏性价比就高很多了。大彩串口屏，很多型号都支持modbus协议，价格甚至只需要几十元就可以搞定，这里我们选择了一款2.8寸的串口屏，型号：DC24320M028_1110_0T。我们通过该串口屏实现和组态屏一样的功能，实现对DI的监控和DO的控制。</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131758911.png" alt="DC24320M028_1110_0T"></p>
<p>​		大彩串口屏的工程见example&#x2F;DACAI，软件采用VisualTFT_3.0.0.1232，界面如下：</p>
<p><img src="https://gitee.com/SenySunny/picture/raw/master/img/202405131759002.png" alt="DACAI"></p>
<p>​		由于我采用的大彩串口屏时RS232&#x2F;TTL-UART接口的，所以这里演示的时候采用了TTL-UART，外接了一个TTL转RS485模块，最终接到我们的RT-thread开发板上。</p>
<h4 id="8、mobus-DTU相关示例"><a href="#8、mobus-DTU相关示例" class="headerlink" title="8、mobus DTU相关示例"></a>8、mobus DTU相关示例</h4><p>​		这里做一个简单的示例，实现modbus TCP转modbus RTU功能。我们用Linux系统开发板上接入USB转RS485模块，连接到rt-thread平台硬件上（用来模拟基于modbus rtu的外设——比如IO模块，传感器外设）。然后再windows上运行modbus tcp master，与linux通信，实现对rt-thread平台硬件上的IIO控制。</p>
<p>​	这里主要验证利用modbus_rt的回调函数功能实现dtu转换功能。</p>
<ol>
<li>首先进入linux平台下的build目录：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/sdcard/modbus_rt/example/linux/pikapython_test/build</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个<code>tcp2rtu_dtu.py</code> 文件，并复制如下代码：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> modbus_rt</span><br><span class="line"><span class="keyword">import</span> modbus_rt_defines <span class="keyword">as</span> cst</span><br><span class="line"></span><br><span class="line">serial_name = <span class="string">&quot;/dev/ttyUSB0&quot;</span></span><br><span class="line">ip_addr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">rm = modbus_rt.rtu(cst.MASTER)</span><br><span class="line">rm.set_serial(serial_name)</span><br><span class="line">rm.<span class="built_in">open</span>()</span><br><span class="line">ts = modbus_rt.tcp()</span><br><span class="line">ts.set_net(ip_addr, <span class="number">502</span>, cst.SOCK_STREAM)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.READ_HOLDING_REGISTERS == function: </span><br><span class="line">        data = rm.excuse(slave, function, addr, quantity)</span><br><span class="line">        ts.excuse(cst.WRITE, cst.REGISTERS, addr, quantity, data)</span><br><span class="line">    <span class="keyword">elif</span> cst.READ_DISCRETE_INPUTS == function: </span><br><span class="line">        data = rm.excuse(slave, function, addr, quantity)</span><br><span class="line">        ts.excuse(cst.WRITE, cst.INPUTS, addr, quantity, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done_call</span>(<span class="params">evt</span>) :</span><br><span class="line">    slave = evt.slave</span><br><span class="line">    function = evt.function</span><br><span class="line">    addr = evt.addr</span><br><span class="line">    quantity = evt.quantity</span><br><span class="line">    <span class="keyword">if</span> cst.WRITE_SINGLE_COIL == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.CIOLS, addr, <span class="number">1</span>)  </span><br><span class="line">        rm.excuse(slave, function, addr, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_SINGLE_REGISTER == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.REGISTERS, addr, <span class="number">1</span>) </span><br><span class="line">        rm.excuse(slave, function, addr, data[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_COILS == function: </span><br><span class="line">        data = ts.excuse(cst.READ, cst.CIOLS, addr, quantity)  </span><br><span class="line">        rm.excuse(slave, function, addr, quantity, data)  </span><br><span class="line">    <span class="keyword">elif</span> cst.WRITE_MULTIPLE_REGISTERS == function: </span><br><span class="line">        data = ts.excuse(<span class="number">0</span>, cst.REGISTERS, addr, quantity)  </span><br><span class="line">        rm.excuse(slave, function, addr, quantity, data)    </span><br><span class="line">ts.add_block(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, <span class="number">20000</span>, <span class="number">10</span>)</span><br><span class="line">ts.add_block(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, <span class="number">10000</span>, <span class="number">16</span>)</span><br><span class="line">ts.add_block(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">ts.set_strict(<span class="number">0</span>)</span><br><span class="line">ts.set_pre_ans_callback(pre_call)</span><br><span class="line">ts.set_done_callback(done_call)</span><br><span class="line">ts.<span class="built_in">open</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​        我们可以看到，代码主要的功能便是创建一个tcp slave和rtu master，并把其写线圈和保持寄存器的指令转化为对rtu master对外的操作。并在接收到读保持寄存器和离散输入寄存器指令的之后，首先通过rtu master获取对应地址的设备的信息，用来更新自己的寄存器信息，以确保读取到的信息为对用的rtu slave设备的信息。</p>
</blockquote>
<ol start="3">
<li>我们运行对应的<code>.py</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./pikapython tcp2rtu_dtu.py</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>之后我们便可以通过modbus master设备来操作dtu下面连接的rtu slave设备了。</li>
</ol>
<blockquote>
<p>后续根据情况可以陆续提供多种应用demo</p>
</blockquote>
<h3 id="四、接口说明"><a href="#四、接口说明" class="headerlink" title="四、接口说明"></a>四、接口说明</h3><h4 id="1、-移植和使用"><a href="#1、-移植和使用" class="headerlink" title="1、 移植和使用"></a>1、 移植和使用</h4><ol>
<li><p>通过modbus_tcp(mode), modbus_rtu(mode)或者modbus_ascii(mode)创建示例，mode：0表示modbus slave; 1表示modbus Master。该函数主要用于创建设备的数据块内容，设备块内容，初始化设备需要用到的互斥量和信号量。</p>
</li>
<li><p>通过modbus_xxx_set_net，modbus_xxx_set_serial等函数初始化相应的参数,详情见API手册</p>
</li>
<li><p>通过modbus_xxx_open开启运行设备，该函数主要用于 建立设备的通信端口，创建通信相关的线程。</p>
</li>
<li><p>如果暂时不需要使用设备，可以使用modbus_xxx_close函数关闭设备，该函数主要用于结束设备通信相关线程，关闭设备的通信接口</p>
</li>
<li><p>如果彻底不适用对应设备了，可以使用modbus_xxx_destroy销毁该设备，该函数主要用于销毁设备的互斥量和信号量相关数，销毁设备的数据信息和设备信。此时设备指针将指向空指针。</p>
</li>
<li><p>slave添加寄存器数据块函数为modbus_xxx_add_block函数。参数分别为寄存器类型(默认0, 1, 3, 4四种)，寄存器其实地址，存储数据的空间地址，寄存器的长度（不是数据长度）。</p>
</li>
<li><p>获取或者修改寄存器的值用modbus_xxx_excuse函数，针对slave模式为读取或者写入自己的寄存器的值，针对master模式为读取或者写入连接slave设备的寄存器的值。</p>
</li>
<li><p>如果要实现dtu或者modbus与其他协议的转换内容，可以通过modbus_xxx_set_pre_ans_callback和modbus_xxx_set_done_callback设置两个回调函数，分别再slave设备收到master端的数据时调用，和modbus通信结束后调用，可以再回调函数中完成协议转换相关的内容（注意回调函数不能为阻塞函数，否则会导致modbus通信超时）。</p>
</li>
<li><p>如果需要把modbus slave设备与设备接口绑定，比如实现DIDO，PWM， ADC，DAC，电机控制，修改PID参数等外设模块，可以把宏定义modbus_config.h中的SLAVE_DATA_DEVICE_BINDING宏定义修改为1，自己完成硬件外设与slave寄存器的绑定工作。详细操作可以参考RT-thread平台的嵌入式demo。大致的操作如下：</p>
<blockquote>
<p>需要自己添加”device_data.h”头文件和完成以下几个函数：</p>
<p>dev_write_bits：       写bits寄存器</p>
<p>dev_read_bits：       读bits寄存器</p>
<p>dev_write_regs：       写regs寄存器</p>
<p>dev_read_regs：       读regs寄存器</p>
<p>dev_data2modbus_slave：   寄存器初始化（绑定slave寄存器和硬件外设信息）</p>
</blockquote>
</li>
<li><p>modbus_xxx_set_strict用在slave模式下，把strict设置为0则通信不会对master发送的数据的设备地址做匹配检测，即任何地址都可以与该slave设备通信，主要目的在于实现dtu和协议转换相关的功能。</p>
</li>
<li><p>modbus_data_xxx相关函数用于对寄存器与各种数据进行相互转化，以满足不同场景下通信的需求，设备默认为小端模式，由于不同设备的大小端模式不相同。可以采用不同的大小端模式对数据进行转换。</p>
</li>
</ol>
<h4 id="2、-四种大小端模式示例"><a href="#2、-四种大小端模式示例" class="headerlink" title="2、 四种大小端模式示例"></a>2、 四种大小端模式示例</h4><ol>
<li><p>小端模式（Little-endian byte swap）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x20001（131073）</p>
</blockquote>
</li>
<li><p>大端模式（Big-endian byte swap）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x10002000（16,777,728‬）</p>
</blockquote>
</li>
<li><p>内部大段，外部小端（Little-endian）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x2000100（33,554,688‬）</p>
</blockquote>
</li>
<li><p>内部小端，外部大端（Big-endian）：</p>
<blockquote>
<p>寄存器0：0x0001，寄存器1：0x0002</p>
<p>表示的数字：0x10002（65538）</p>
</blockquote>
</li>
</ol>
<h3 id="五、-项目参考或者用到的开源项目"><a href="#五、-项目参考或者用到的开源项目" class="headerlink" title="五、 项目参考或者用到的开源项目"></a>五、 项目参考或者用到的开源项目</h3><p>​	本项目参考或者使用了如下开源项目的内容，再此对以下项目的创作者表示感谢。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/loogg/agile_modbus">agile_modbus(一款开源的支持跨平台的轻量型 modbus 协议栈): https://github.com/loogg/agile_modbus</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sigrokproject/libserialport">libserialport(一款跨平台的串口库): https://github.com/sigrokproject/libserialport</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pikasTech/PikaPython">PikaPython(一个完全重写的超轻量级 python 引擎): https://github.com/pikasTech/PikaPython</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/Lyon1998/pikapython_openhardware"> PikaPython-OpenHardware(一款验证pikapython的ESP32-S3开发板): https://gitee.com/Lyon1998/pikapython_openhardware</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/RT-Thread/rt-thread">RT-Thread(一款以开源的物联网操作系统): https://github.com/RT-Thread/rt-thread</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS">FreeRTOS(一款微控制器的开源实时操作系统): https://github.com/FreeRTOS/FreeRTOS</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://senyblog.com">SenySunny</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://senyblog.com/articles/modbus_0001.html">http://senyblog.com/articles/modbus_0001.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://senyblog.com" target="_blank">SenySunny</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a><a class="post-meta__tags" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a><a class="post-meta__tags" href="/tags/modbus/">modbus</a><a class="post-meta__tags" href="/tags/%E7%89%A9%E8%81%94%E7%BD%91/">物联网</a><a class="post-meta__tags" href="/tags/PLC/">PLC</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/ESP32/">ESP32</a><a class="post-meta__tags" href="/tags/CAT1/">CAT1</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/SenySunny/picture/raw/master/img/modbus.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/SenySunny/picture/raw/master/img/QCode_WeChat.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/SenySunny/picture/raw/master/img/QCode_WeChat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/SenySunny/picture/raw/master/img/QCode_Alipay.png" target="_blank"><img class="post-qr-code-img" src="https://gitee.com/SenySunny/picture/raw/master/img/QCode_Alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/articles/git_0001.html" title="git学习笔记（一）：git客户端基本使用方法"><img class="cover" src="https://gitee.com/SenySunny/picture/raw/master/img/git_l.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git学习笔记（一）：git客户端基本使用方法</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-modbus-rt%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">1、 modbus_rt的主要特性如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81-modbus-rt%E7%9A%84%E5%87%A0%E7%82%B9%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">2、 modbus_rt的几点补充说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%87%8D%E5%A4%A7%E7%9A%84%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-text">二、重大的更新记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%812024-03-01%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9"><span class="toc-text">1、2024-03-01更新内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%812024-01-31%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9"><span class="toc-text">2、2024-01-31更新内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">三、测试与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-windows%E5%B9%B3%E5%8F%B0"><span class="toc-text">1、 windows平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Linux%E5%B9%B3%E5%8F%B0"><span class="toc-text">2、Linux平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81RT-Thread%E5%B9%B3%E5%8F%B0"><span class="toc-text">3、RT-Thread平台</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E5%9F%BA%E4%BA%8EAPM32E103VET6-W5500"><span class="toc-text">（1） 基于APM32E103VET6 + W5500</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%9F%BA%E4%BA%8ESTM32F407-lan8720A-lwip"><span class="toc-text">（2） 基于STM32F407 + lan8720A + lwip</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81FreeRTOS%E5%B9%B3%E5%8F%B0"><span class="toc-text">4、FreeRTOS平台</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E5%9F%BA%E4%BA%8EESP32%EF%BC%8C%E9%87%87%E7%94%A8ESP-IDF%E7%8E%AF%E5%A2%83"><span class="toc-text">（1） 基于ESP32，采用ESP-IDF环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%9F%BA%E4%BA%8Eair780e%EF%BC%8C%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%EF%BC%8C%E5%B0%81%E8%A3%85pikapython%EF%BC%8C%E9%87%87%E7%94%A8xmake%E7%BC%96%E8%AF%91"><span class="toc-text">（2） 基于air780e，基于C语言，封装pikapython，采用xmake编译</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81mosbus-rt%E4%B8%8E%E8%A5%BF%E9%97%A8%E5%AD%90PLC%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">5、mosbus_rt与西门子PLC进行通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81modbus-rt%E4%B8%8E%E7%BB%84%E6%80%81%E5%B1%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">6、modbus_rt与组态屏进行通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81modbus-rt%E4%B8%8E%E5%9B%BD%E4%BA%A7%E5%A4%A7%E5%BD%A9%E4%B8%B2%E5%8F%A3%E5%B1%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">7、modbus_rt与国产大彩串口屏进行通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81mobus-DTU%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B"><span class="toc-text">8、mobus DTU相关示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E"><span class="toc-text">四、接口说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">1、 移植和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81-%E5%9B%9B%E7%A7%8D%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-text">2、 四种大小端模式示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E9%A1%B9%E7%9B%AE%E5%8F%82%E8%80%83%E6%88%96%E8%80%85%E7%94%A8%E5%88%B0%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-text">五、 项目参考或者用到的开源项目</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/" style="font-size:16px;" target="_blank">赣ICP备20003948号</a><p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://senysunny-senysunny.hf.space',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://senysunny-senysunny.hf.space',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>